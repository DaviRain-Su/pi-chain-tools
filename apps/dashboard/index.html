<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NEAR Agent Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #080d1f;
        --bg-2: #0d1530;
        --card: rgba(19, 29, 58, 0.72);
        --card-2: rgba(22, 35, 71, 0.9);
        --border: rgba(125, 156, 255, 0.18);
        --text: #ecf2ff;
        --muted: #9baddf;
        --accent: #7fa2ff;
        --accent-2: #89f0ff;
        --ok: #89f5ae;
        --warn: #ffd486;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: var(--text);
        background:
          radial-gradient(900px 500px at -10% -10%, #27408a44 0%, transparent 65%),
          radial-gradient(900px 500px at 110% -20%, #32bfd433 0%, transparent 60%),
          linear-gradient(160deg, var(--bg) 0%, var(--bg-2) 100%);
        min-height: 100vh;
      }

      .wrap {
        max-width: 1120px;
        margin: 0 auto;
        padding: 28px 20px 40px;
      }

      h1 {
        margin: 0 0 8px;
        font-size: 30px;
        letter-spacing: 0.2px;
      }

      h3 {
        margin: 0 0 10px;
        font-size: 17px;
        letter-spacing: 0.2px;
      }

      .muted { color: var(--muted); }

      .grid {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }

      .card {
        background: linear-gradient(180deg, var(--card) 0%, var(--card-2) 100%);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 14px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.22);
      }

      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      input, button, textarea {
        border-radius: 10px;
        border: 1px solid #34456f;
        background: #0d1731;
        color: var(--text);
        padding: 8px 10px;
        transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.08s ease;
      }

      input:focus, textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(127, 162, 255, 0.18);
      }

      button {
        cursor: pointer;
        background: linear-gradient(180deg, #1a2a55 0%, #142245 100%);
        border-color: #3d5896;
        font-weight: 600;
      }

      button:hover {
        border-color: #6f93f5;
        box-shadow: 0 6px 18px rgba(111, 147, 245, 0.25);
      }

      button:active { transform: translateY(1px); }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        overflow: hidden;
        border-radius: 10px;
      }

      th, td {
        padding: 10px 8px;
        border-bottom: 1px solid #27385f;
        text-align: left;
        font-size: 13px;
      }

      th {
        color: #c9d7ff;
        font-weight: 600;
        background: rgba(14, 23, 49, 0.65);
        position: sticky;
        top: 0;
      }

      tr:hover td { background: rgba(146, 178, 255, 0.06); }

      .ok {
        color: var(--ok);
        font-weight: 600;
      }

      .warn {
        color: var(--warn);
        font-weight: 600;
      }

      a {
        color: var(--accent-2);
        text-decoration: none;
      }

      a:hover { text-decoration: underline; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>NEAR Agent Dashboard</h1>
      <p class="muted">Portfolio + Burrow + worker/runtime status in one page.</p>
      <div class="row" style="margin-bottom:16px">
        <input id="accountId" size="36" placeholder="account.near" />
        <button id="refresh">Refresh</button>
        <span id="meta" class="muted"></span>
      </div>

      <div class="grid">
        <div class="card"><h3>NEAR Wallet</h3><div id="near">-</div></div>
        <div class="card"><h3>Burrow Registration</h3><div id="burrowReg">-</div></div>
        <div class="card"><h3>Yield Worker</h3><div id="worker">-</div></div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Yield Health</h3>
        <div id="yieldHealth" class="muted">-</div>
        <div id="bscProtocolHealth" class="muted" style="margin-top:6px">BSC protocol: -</div>
        <div class="row" style="margin-top:6px">
          <label class="muted" for="bscExecutionProtocol">readiness protocol</label>
          <select id="bscExecutionProtocol">
            <option value="aave">aave</option>
            <option value="lista">lista</option>
            <option value="wombat">wombat</option>
            <option value="venus">venus</option>
          </select>
        </div>
        <div id="bscYieldReadiness" class="muted" style="margin-top:6px">BSC execute readiness: -</div>
        <div id="bscMarketHealth" class="muted" style="margin-top:6px">BSC market health: -</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Execution Quality</h3>
        <div id="execQuality" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>deBridge Execute Reliability</h3>
        <div class="row" style="margin-bottom:8px">
          <label class="muted" for="debridgeWindow">window</label>
          <select id="debridgeWindow">
            <option value="1h">1h</option>
            <option value="24h" selected>24h</option>
            <option value="7d">7d</option>
          </select>
          <button id="copyDebridgeReliability">Copy summary</button>
          <button id="copyDebridgeIncident">Copy incident format</button>
          <button id="fillDebridgeFixDraft">Fill fix draft</button>
          <button id="appendDebridgeQuickFix">Append quick fix</button>
          <button id="appendQuickFixTimeout">+ timeout</button>
          <button id="appendQuickFixRate">+ rate-limit</button>
          <button id="appendQuickFixNetwork">+ network</button>
        </div>
        <div id="debridgeReliability" class="muted" style="white-space:pre-wrap">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>ACP Ops</h3>
        <div id="acpOps" class="muted">-</div>
        <div class="row" style="margin-top:8px">
          <input id="acpAsyncStrategyId" placeholder="strategyId (optional)" size="20" />
          <input id="acpAsyncBuyer" placeholder="buyer (for entitlement)" size="20" />
          <input id="acpAsyncAmountRaw" placeholder="amountRaw (default 1000000)" size="20" />
          <button id="submitAcpAsyncJob">Submit ACP Async Job</button>
          <span id="acpAsyncMeta" class="muted"></span>
        </div>
        <div id="acpAsyncStatus" class="muted" style="margin-top:6px">-</div>
        <div id="acpDeadLetters" class="muted" style="margin-top:6px">dead-letter: -</div>
        <div class="row" style="margin-top:4px">
          <select id="acpDeadPhaseFilter">
            <option value="all">dead-letter phase: all</option>
            <option value="main">dead-letter phase: main</option>
            <option value="bsc-aave-post">dead-letter phase: bsc-aave-post</option>
          </select>
          <select id="acpDeadTypeFilter">
            <option value="all">dead-letter type: all</option>
          </select>
          <button id="acpDeadPresetAave">Preset: Aave post failures</button>
          <button id="acpDeadPresetMain">Preset: Main failures</button>
          <button id="acpDeadPresetAll">Preset: Clear presets</button>
        </div>
        <div id="acpDismissed" class="muted" style="margin-top:4px">dismissed: -</div>
        <div class="row" style="margin-top:6px">
          <div id="acpFailureHeatmap" class="muted" style="flex:1">failure heatmap: -</div>
          <select id="acpHeatmapWindow" style="width:130px">
            <option value="1h">1h</option>
            <option value="24h" selected>24h</option>
            <option value="7d">7d</option>
          </select>
        </div>
        <div class="row" style="margin-top:4px">
          <input id="acpDismissedPurgeDays" type="number" min="0" value="7" style="width:88px" />
          <button id="acpDismissedPurgeBtn">Purge dismissed older than days</button>
        </div>
        <details style="margin-top:10px">
          <summary>Recent ACP Jobs</summary>
          <div class="row" style="margin:8px 0">
            <label class="muted" for="acpStatusFilter">Status</label>
            <select id="acpStatusFilter">
              <option value="all">all</option>
              <option value="dry-run">dry-run</option>
              <option value="planned">planned</option>
              <option value="executed">executed</option>
              <option value="blocked">blocked</option>
              <option value="error">error</option>
            </select>
            <input id="acpBuyerFilter" placeholder="buyer filter" size="16" />
            <input id="acpStrategyFilter" placeholder="strategyId filter" size="16" />
            <select id="acpPhaseFilter">
              <option value="all">phase: all</option>
              <option value="main">phase: main</option>
              <option value="bsc-aave-post">phase: bsc-aave-post</option>
            </select>
            <label class="muted" style="display:flex;align-items:center;gap:4px"><input id="acpOnlyFailed" type="checkbox" />only failed</label>
            <label class="muted" style="display:flex;align-items:center;gap:4px"><input id="acpExpandErrors" type="checkbox" checked />auto-expand errors</label>
            <button id="copyAcpFilterLink">Copy filter link</button>
            <button id="resetAcpFilters">Reset filters</button>
          </div>
          <table style="margin-top:8px">
            <thead><tr><th>Time</th><th>RunId</th><th>Status</th><th>Chain</th><th>Intent</th><th>Protocol</th><th>PostAction</th><th>Strategy</th><th>Buyer</th><th>Remaining</th><th>AmountRaw</th><th>Tx</th></tr></thead>
            <tbody id="acpJobs"></tbody>
          </table>
        </details>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Target Allocation Alert</h3>
        <div class="row" style="margin-bottom:8px">
          <input id="targetUsdt" type="number" min="0" max="100" step="0.1" placeholder="USDt target %" size="14" />
          <input id="targetUsdce" type="number" min="0" max="100" step="0.1" placeholder="USDC.e target %" size="14" />
          <input id="targetThreshold" type="number" min="0" max="100" step="0.1" placeholder="Alert threshold %" size="16" />
          <button id="saveTargets">Save</button>
        </div>
        <div id="targetAlert" class="muted">-</div>
        <div id="targetPlan" class="muted" style="margin-top:8px">-</div>
        <div style="margin-top:10px">
          <textarea id="rebalanceDraft" rows="6" style="width:100%;border-radius:8px;border:1px solid #2d3656;background:#0e1529;color:#e8eefc;padding:8px" placeholder="Rebalance execution draft will appear here"></textarea>
        </div>
        <div class="row" style="margin-top:8px">
          <select id="rebalanceChain">
            <option value="near">near</option>
            <option value="bsc">bsc</option>
          </select>
          <button id="buildRebalanceDraft">Build execution draft</button>
          <button id="copyRebalanceDraft">Copy draft</button>
          <button id="fillActionConsole">Fill Action Console</button>
          <button id="execRebalanceTxn">Execute Rebalance Txn (auto rollback)</button>
          <span id="rebalanceMeta" class="muted"></span>
        </div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Strategy View</h3>
        <div id="strategy" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Payments</h3>
        <div id="paymentsMeta" class="muted">-</div>
        <table style="margin-top:8px">
          <thead><tr><th>Time</th><th>PaymentId</th><th>Status</th><th>Strategy</th><th>Buyer</th><th>Amount</th></tr></thead>
          <tbody id="paymentsRows"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Strategy DSL Validate (Preflight)</h3>
        <p class="muted">Validate strategy DSL without persisting (schema + semantic policy checks).</p>
        <textarea id="strategyDslInput" rows="8" style="width:100%;border-radius:8px;border:1px solid #2d3656;background:#0e1529;color:#e8eefc;padding:8px"></textarea>
        <div class="row" style="margin-top:8px">
          <button id="fillStrategyDslSample">Fill sample</button>
          <button id="validateStrategyDsl">Validate DSL</button>
          <button id="publishStrategyDsl">Publish Strategy</button>
          <span id="strategyDslMeta" class="muted"></span>
        </div>
        <pre id="strategyDslResult" class="muted" style="white-space:pre-wrap;margin-top:8px">-</pre>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Burrow Positions</h3>
        <div id="burrowPos" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Tracked Token Balances</h3>
        <table>
          <thead><tr><th>Token</th><th>Balance</th><th>~USD</th><th>Status</th></tr></thead>
          <tbody id="tokens"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Recent Executions (local session)</h3>
        <div class="row" style="margin-bottom:8px">
          <button id="exportCsv">Export snapshot CSV</button>
          <span id="exportMeta" class="muted"></span>
        </div>
        <table>
          <thead><tr><th>Time</th><th>Tool</th><th>Tx Hash</th></tr></thead>
          <tbody id="txs"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Action History</h3>
        <table>
          <thead><tr><th>Time</th><th>Action</th><th>Step</th><th>Status</th><th>Tx</th><th>Summary</th></tr></thead>
          <tbody id="actions"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Action Console</h3>
        <p class="muted">Supports command build + confirmed direct execution for selected actions.</p>
        <div class="row">
          <input id="wrapAmount" placeholder="Wrap amount NEAR (e.g. 1)" size="24" />
          <button id="buildWrap">Build wrap command</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="supplyRaw" placeholder="Supply raw (USDt, e.g. 1000000)" size="24" />
          <button id="buildSupply">Build supply command</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="execWrap">Execute wrap (confirmed)</button>
          <button id="execSupply">Execute supply USDt (confirmed)</button>
          <input id="execStepTag" placeholder="step tag (e.g. step1)" size="16" />
        </div>
        <div class="row" style="margin-top:8px">
          <button id="buildWorkerDry">Build worker dry-run start</button>
          <button id="buildWorkerStop">Build worker stop</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="buildStep1">Build Step1 (withdraw)</button>
          <button id="buildStep2">Build Step2 (swap)</button>
          <input id="step2OutRaw" placeholder="Step2 output raw" size="18" />
          <button id="buildStep3">Build Step3 (supply)</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="step2ResultText" placeholder="Paste Step2 result text here" size="42" />
          <button id="parseStep2Raw">Parse output raw</button>
        </div>
        <div style="margin-top:10px">
          <textarea id="cmdOut" rows="6" style="width:100%;border-radius:8px;border:1px solid #2d3656;background:#0e1529;color:#e8eefc;padding:8px"></textarea>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="copyCmd">Copy command</button>
          <button id="testAlerts">Test alerts</button>
          <span id="cmdMeta" class="muted"></span>
        </div>
      </div>
    </div>

    <script>
      const accountInput = document.getElementById("accountId");
      const refreshBtn = document.getElementById("refresh");
      const nearEl = document.getElementById("near");
      const burrowRegEl = document.getElementById("burrowReg");
      const workerEl = document.getElementById("worker");
      const yieldHealthEl = document.getElementById("yieldHealth");
      const bscProtocolHealthEl = document.getElementById("bscProtocolHealth");
      const bscYieldReadinessEl = document.getElementById("bscYieldReadiness");
      const bscExecutionProtocolEl = document.getElementById("bscExecutionProtocol");
      const bscMarketHealthEl = document.getElementById("bscMarketHealth");
      const execQualityEl = document.getElementById("execQuality");
      const debridgeReliabilityEl = document.getElementById("debridgeReliability");
      const debridgeWindowEl = document.getElementById("debridgeWindow");
      const copyDebridgeReliabilityBtn = document.getElementById("copyDebridgeReliability");
      const copyDebridgeIncidentBtn = document.getElementById("copyDebridgeIncident");
      const fillDebridgeFixDraftBtn = document.getElementById("fillDebridgeFixDraft");
      const appendDebridgeQuickFixBtn = document.getElementById("appendDebridgeQuickFix");
      const appendQuickFixTimeoutBtn = document.getElementById("appendQuickFixTimeout");
      const appendQuickFixRateBtn = document.getElementById("appendQuickFixRate");
      const appendQuickFixNetworkBtn = document.getElementById("appendQuickFixNetwork");
      const acpOpsEl = document.getElementById("acpOps");
      const acpJobsEl = document.getElementById("acpJobs");
      const acpStatusFilterEl = document.getElementById("acpStatusFilter");
      const acpBuyerFilterEl = document.getElementById("acpBuyerFilter");
      const acpStrategyFilterEl = document.getElementById("acpStrategyFilter");
      const acpOnlyFailedEl = document.getElementById("acpOnlyFailed");
      const acpPhaseFilterEl = document.getElementById("acpPhaseFilter");
      const acpExpandErrorsEl = document.getElementById("acpExpandErrors");
      const copyAcpFilterLinkBtn = document.getElementById("copyAcpFilterLink");
      const resetAcpFiltersBtn = document.getElementById("resetAcpFilters");
      const acpAsyncStrategyIdEl = document.getElementById("acpAsyncStrategyId");
      const acpAsyncBuyerEl = document.getElementById("acpAsyncBuyer");
      const acpAsyncAmountRawEl = document.getElementById("acpAsyncAmountRaw");
      const submitAcpAsyncJobBtn = document.getElementById("submitAcpAsyncJob");
      const acpAsyncMetaEl = document.getElementById("acpAsyncMeta");
      const acpAsyncStatusEl = document.getElementById("acpAsyncStatus");
      const acpDeadLettersEl = document.getElementById("acpDeadLetters");
      const acpDismissedEl = document.getElementById("acpDismissed");
      const acpFailureHeatmapEl = document.getElementById("acpFailureHeatmap");
      const acpHeatmapWindowEl = document.getElementById("acpHeatmapWindow");
      const acpDeadPhaseFilterEl = document.getElementById("acpDeadPhaseFilter");
      const acpDeadTypeFilterEl = document.getElementById("acpDeadTypeFilter");
      const acpDeadPresetAaveBtn = document.getElementById("acpDeadPresetAave");
      const acpDeadPresetMainBtn = document.getElementById("acpDeadPresetMain");
      const acpDeadPresetAllBtn = document.getElementById("acpDeadPresetAll");
      const acpDismissedPurgeDaysEl = document.getElementById("acpDismissedPurgeDays");
      const acpDismissedPurgeBtn = document.getElementById("acpDismissedPurgeBtn");
      const strategyEl = document.getElementById("strategy");
      const paymentsMetaEl = document.getElementById("paymentsMeta");
      const paymentsRowsEl = document.getElementById("paymentsRows");
      const strategyDslInputEl = document.getElementById("strategyDslInput");
      const fillStrategyDslSampleBtn = document.getElementById("fillStrategyDslSample");
      const validateStrategyDslBtn = document.getElementById("validateStrategyDsl");
      const publishStrategyDslBtn = document.getElementById("publishStrategyDsl");
      const strategyDslMetaEl = document.getElementById("strategyDslMeta");
      const strategyDslResultEl = document.getElementById("strategyDslResult");
      const targetUsdtEl = document.getElementById("targetUsdt");
      const targetUsdceEl = document.getElementById("targetUsdce");
      const targetThresholdEl = document.getElementById("targetThreshold");
      const saveTargetsBtn = document.getElementById("saveTargets");
      const targetAlertEl = document.getElementById("targetAlert");
      const targetPlanEl = document.getElementById("targetPlan");
      const rebalanceDraftEl = document.getElementById("rebalanceDraft");
      const rebalanceChainEl = document.getElementById("rebalanceChain");
      const buildRebalanceDraftBtn = document.getElementById("buildRebalanceDraft");
      const copyRebalanceDraftBtn = document.getElementById("copyRebalanceDraft");
      const fillActionConsoleBtn = document.getElementById("fillActionConsole");
      const execRebalanceTxnBtn = document.getElementById("execRebalanceTxn");
      const rebalanceMetaEl = document.getElementById("rebalanceMeta");
      const burrowPosEl = document.getElementById("burrowPos");
      const metaEl = document.getElementById("meta");
      const tokensEl = document.getElementById("tokens");
      const txsEl = document.getElementById("txs");
      const exportCsvBtn = document.getElementById("exportCsv");
      const exportMetaEl = document.getElementById("exportMeta");
      const actionsEl = document.getElementById("actions");
      const wrapAmountEl = document.getElementById("wrapAmount");
      const supplyRawEl = document.getElementById("supplyRaw");
      const buildWrapBtn = document.getElementById("buildWrap");
      const buildSupplyBtn = document.getElementById("buildSupply");
      const buildWorkerDryBtn = document.getElementById("buildWorkerDry");
      const buildWorkerStopBtn = document.getElementById("buildWorkerStop");
      const buildStep1Btn = document.getElementById("buildStep1");
      const buildStep2Btn = document.getElementById("buildStep2");
      const buildStep3Btn = document.getElementById("buildStep3");
      const step2OutRawEl = document.getElementById("step2OutRaw");
      const step2ResultTextEl = document.getElementById("step2ResultText");
      const parseStep2RawBtn = document.getElementById("parseStep2Raw");
      const execWrapBtn = document.getElementById("execWrap");
      const execSupplyBtn = document.getElementById("execSupply");
      const execStepTagEl = document.getElementById("execStepTag");
      const cmdOutEl = document.getElementById("cmdOut");
      const copyCmdBtn = document.getElementById("copyCmd");
      const testAlertsBtn = document.getElementById("testAlerts");
      const cmdMetaEl = document.getElementById("cmdMeta");

      function rowsToText(rows) {
        if (!rows || rows.length === 0) return "none";
        return rows.map((r) => `${r.symbol}: ${r.amount}`).join(" Â· ");
      }

      function applyAcpFiltersFromStorage() {
        try {
          const s = JSON.parse(localStorage.getItem(ACP_FILTERS_KEY) || "{}");
          if (acpStatusFilterEl && s.acpStatus) acpStatusFilterEl.value = s.acpStatus;
          if (acpBuyerFilterEl && typeof s.acpBuyer === "string") acpBuyerFilterEl.value = s.acpBuyer;
          if (acpStrategyFilterEl && typeof s.acpStrategy === "string") acpStrategyFilterEl.value = s.acpStrategy;
          if (acpOnlyFailedEl) acpOnlyFailedEl.checked = s.acpOnlyFailed === true;
          if (acpPhaseFilterEl && s.acpPhase) acpPhaseFilterEl.value = s.acpPhase;
          if (acpDeadPhaseFilterEl && s.acpDeadPhase) acpDeadPhaseFilterEl.value = s.acpDeadPhase;
          if (acpDeadTypeFilterEl && s.acpDeadType) acpDeadTypeFilterEl.value = s.acpDeadType;
          if (acpHeatmapWindowEl && s.acpHeatmapWindow) acpHeatmapWindowEl.value = s.acpHeatmapWindow;
          if (acpExpandErrorsEl) acpExpandErrorsEl.checked = s.acpExpandErrors !== false;
        } catch {}
      }

      function applyAcpFiltersFromUrl() {
        if (!window.location.search) return;
        const p = new URLSearchParams(window.location.search);
        if (acpStatusFilterEl && p.get("acpStatus")) acpStatusFilterEl.value = p.get("acpStatus");
        if (acpBuyerFilterEl && p.get("acpBuyer")) acpBuyerFilterEl.value = p.get("acpBuyer");
        if (acpStrategyFilterEl && p.get("acpStrategy")) acpStrategyFilterEl.value = p.get("acpStrategy");
        if (acpOnlyFailedEl && p.get("acpOnlyFailed")) acpOnlyFailedEl.checked = p.get("acpOnlyFailed") === "1";
        if (acpPhaseFilterEl && p.get("acpPhase")) acpPhaseFilterEl.value = p.get("acpPhase");
        if (acpDeadPhaseFilterEl && p.get("acpDeadPhase")) acpDeadPhaseFilterEl.value = p.get("acpDeadPhase");
        if (acpDeadTypeFilterEl && p.get("acpDeadType")) acpDeadTypeFilterEl.value = p.get("acpDeadType");
        if (acpHeatmapWindowEl && p.get("acpHeatmapWindow")) acpHeatmapWindowEl.value = p.get("acpHeatmapWindow");
      }

      function saveAcpFiltersToStorage() {
        const payload = {
          acpStatus: acpStatusFilterEl?.value || "all",
          acpBuyer: acpBuyerFilterEl?.value || "",
          acpStrategy: acpStrategyFilterEl?.value || "",
          acpOnlyFailed: !!acpOnlyFailedEl?.checked,
          acpPhase: acpPhaseFilterEl?.value || "all",
          acpDeadPhase: acpDeadPhaseFilterEl?.value || "all",
          acpDeadType: acpDeadTypeFilterEl?.value || "all",
          acpHeatmapWindow: acpHeatmapWindowEl?.value || "24h",
          acpExpandErrors: !!acpExpandErrorsEl?.checked,
        };
        localStorage.setItem(ACP_FILTERS_KEY, JSON.stringify(payload));
      }

      function syncAcpFiltersToUrl() {
        saveAcpFiltersToStorage();
        const qp = new URLSearchParams(window.location.search);
        const setOrDelete = (key, val) => {
          if (val === undefined || val === null || String(val) === "") qp.delete(key);
          else qp.set(key, String(val));
        };
        setOrDelete("acpStatus", acpStatusFilterEl?.value || "all");
        setOrDelete("acpBuyer", acpBuyerFilterEl?.value || "");
        setOrDelete("acpStrategy", acpStrategyFilterEl?.value || "");
        setOrDelete("acpOnlyFailed", acpOnlyFailedEl?.checked ? "1" : "");
        setOrDelete("acpPhase", acpPhaseFilterEl?.value || "all");
        setOrDelete("acpDeadPhase", acpDeadPhaseFilterEl?.value || "all");
        setOrDelete("acpDeadType", acpDeadTypeFilterEl?.value || "all");
        setOrDelete("acpHeatmapWindow", acpHeatmapWindowEl?.value || "24h");
        const next = `${window.location.pathname}?${qp.toString()}`.replace(/\?$/, "");
        window.history.replaceState(null, "", next);
      }

      function resetAcpFilters() {
        if (acpStatusFilterEl) acpStatusFilterEl.value = "all";
        if (acpBuyerFilterEl) acpBuyerFilterEl.value = "";
        if (acpStrategyFilterEl) acpStrategyFilterEl.value = "";
        if (acpOnlyFailedEl) acpOnlyFailedEl.checked = false;
        if (acpPhaseFilterEl) acpPhaseFilterEl.value = "all";
        if (acpDeadPhaseFilterEl) acpDeadPhaseFilterEl.value = "all";
        if (acpDeadTypeFilterEl) acpDeadTypeFilterEl.value = "all";
        if (acpHeatmapWindowEl) acpHeatmapWindowEl.value = "24h";
        if (acpExpandErrorsEl) acpExpandErrorsEl.checked = true;
        syncAcpFiltersToUrl();
      }

      function parseNum(value) {
        const n = Number.parseFloat(String(value || "0"));
        return Number.isFinite(n) ? n : 0;
      }

      const TARGET_KEY = "near-dashboard-targets-v1";
      const ACP_FILTERS_KEY = "near-dashboard-acp-filters-v1";

      function loadTargets() {
        try {
          const parsed = JSON.parse(localStorage.getItem(TARGET_KEY) || "{}");
          return {
            usdt: parseNum(parsed.usdt) || 70,
            usdce: parseNum(parsed.usdce) || 30,
            threshold: parseNum(parsed.threshold) || 10,
          };
        } catch {
          return { usdt: 70, usdce: 30, threshold: 10 };
        }
      }

      function saveTargets(targets) {
        localStorage.setItem(TARGET_KEY, JSON.stringify(targets));
      }

      function normalizeStableSymbol(symbol) {
        const s = String(symbol || "").toUpperCase();
        if (s === "USDT" || s === "USDT.E" || s === "USDT") return "USDT";
        if (s === "USDC.E") return "USDC.E";
        if (s === "USDCE") return "USDC.E";
        return s;
      }

      function getStableMix(snapshot) {
        const coll = snapshot?.burrow?.collateral || [];
        const stable = coll.map((r) => ({
          symbol: normalizeStableSymbol(r.symbol),
          amount: parseNum(r.amount),
        }));
        const total = stable.reduce((sum, r) => sum + r.amount, 0);
        const usdt = stable.filter((r) => r.symbol === "USDT").reduce((s, r) => s + r.amount, 0);
        const usdce = stable.filter((r) => r.symbol === "USDC.E").reduce((s, r) => s + r.amount, 0);
        return { total, usdt, usdce };
      }

      function computeTargetAlert(snapshot, targets) {
        const mix = getStableMix(snapshot);
        if (mix.total <= 0) return "No collateral yet, target tracking pending.";

        const usdtPct = (mix.usdt / mix.total) * 100;
        const usdcePct = (mix.usdce / mix.total) * 100;

        const usdtDelta = usdtPct - targets.usdt;
        const usdceDelta = usdcePct - targets.usdce;
        const alert =
          Math.abs(usdtDelta) > targets.threshold ||
          Math.abs(usdceDelta) > targets.threshold;

        const status = alert
          ? `<span class="warn">ALERT</span>`
          : `<span class="ok">ON TARGET</span>`;

        return `${status} Â· USDt ${usdtPct.toFixed(1)}% (target ${targets.usdt.toFixed(
          1,
        )}%, Î” ${usdtDelta >= 0 ? "+" : ""}${usdtDelta.toFixed(
          1,
        )}%) Â· USDC.e ${usdcePct.toFixed(1)}% (target ${targets.usdce.toFixed(
          1,
        )}%, Î” ${usdceDelta >= 0 ? "+" : ""}${usdceDelta.toFixed(1)}%)`;
      }

      function computeRebalancePlan(snapshot, targets) {
        const mix = getStableMix(snapshot);
        if (mix.total <= 0) {
          return { text: "No rebalance plan: stable collateral is empty.", amount: 0, from: null, to: null };
        }

        const targetUsdtAmount = (targets.usdt / 100) * mix.total;
        const targetUsdceAmount = (targets.usdce / 100) * mix.total;
        const usdtGap = targetUsdtAmount - mix.usdt;
        const usdceGap = targetUsdceAmount - mix.usdce;

        if (Math.abs(usdtGap) < 0.000001 && Math.abs(usdceGap) < 0.000001) {
          return { text: "Rebalance plan: already at target.", amount: 0, from: null, to: null };
        }

        if (usdtGap > 0 && usdceGap < 0) {
          const amount = Math.min(usdtGap, -usdceGap);
          return {
            text: `Suggestion: move ${amount.toFixed(6)} from USDC.e -> USDt.`,
            amount,
            from: "USDC.e",
            to: "USDt",
          };
        }

        if (usdceGap > 0 && usdtGap < 0) {
          const amount = Math.min(usdceGap, -usdtGap);
          return {
            text: `Suggestion: move ${amount.toFixed(6)} from USDt -> USDC.e.`,
            amount,
            from: "USDt",
            to: "USDC.e",
          };
        }

        return {
          text: `Suggestion: adjust composition manually (USDt gap ${usdtGap.toFixed(6)}, USDC.e gap ${usdceGap.toFixed(6)}).`,
          amount: 0,
          from: null,
          to: null,
        };
      }

      function computeYieldHealth(snapshot) {
        const coll = snapshot?.burrow?.collateral || [];
        if (coll.length === 0) {
          return "No stable collateral yet.";
        }
        const rows = coll.map((r) => ({
          symbol: r.symbol,
          amount: parseNum(r.amount),
          apr: parseNum(r.apr) * 100,
        }));
        const total = rows.reduce((sum, r) => sum + r.amount, 0);
        const weightedApr = total > 0 ? rows.reduce((sum, r) => sum + r.amount * r.apr, 0) / total : 0;
        const composition = rows
          .sort((a, b) => b.amount - a.amount)
          .map((r) => `${r.symbol} ${(total > 0 ? (r.amount / total) * 100 : 0).toFixed(1)}% @ ${r.apr.toFixed(2)}%`)
          .join(" Â· ");
        return `Estimated weighted APR: ${weightedApr.toFixed(2)}% Â· Collateral total: ${total.toFixed(6)} Â· ${composition}`;
      }

      function computeExecutionQuality(snapshot) {
        const m = snapshot?.rebalanceMetrics;
        if (!m) return "No execution metrics yet.";
        const total = Number(m.totalRuns || 0);
        const success = Number(m.successRuns || 0);
        const failed = Number(m.failedRuns || 0);
        const rollback = Number(m.rollbackRuns || 0);
        const reconcileWarn = Number(m.reconcileWarnings || 0);
        const successRate = total > 0 ? (success / total) * 100 : 0;
        const latest = (m.recent || [])[0] || null;
        const latestText = latest
          ? `Latest: ${latest.status} Â· runId=${latest.runId || "-"}`
          : "Latest: -";
        const latestPnl = (m.pnlSeries || [])[0] || null;
        const pnlText = latestPnl
          ? `Î”stable: ${(Number(latestPnl.deltaStable || 0)).toFixed(6)} (before ${Number(latestPnl.beforeTotalStable || 0).toFixed(6)} -> after ${Number(latestPnl.afterTotalStable || 0).toFixed(6)})`
          : "Î”stable: n/a";
        const r = snapshot?.rpcMetrics || {};
        const retryRate = Number(r.retryRate || 0) * 100;
        const rpcText = `RPC attempts=${Number(r.totalAttempts || 0)} retries=${Number(r.totalRetries || 0)} retryRate=${retryRate.toFixed(1)}% 429=${Number(r.http429 || 0)} 5xx=${Number(r.http5xx || 0)}`;
        const rpcDetail = `lastOK=${r.lastSuccessEndpoint || "-"} lastErr=${r.lastError || "-"}`;
        const top = (r.ranking || [])[0] || null;
        const topText = top
          ? `best=${top.endpoint} score=${Number(top.score || 0).toFixed(2)}`
          : "best=-";
        const w = snapshot?.paymentWebhookMetrics || {};
        const webhookText = `Webhook accepted=${Number(w.accepted || 0)} idempotent=${Number(w.idempotent || 0)} rejected=${Number(w.rejected || 0)} lastProvider=${w.lastProvider || '-'} lastErr=${w.lastError || '-'}`;
        const d = snapshot?.debridgeExecuteMetrics || {};
        const debridgeText = `deBridge exec total=${Number(d.total || 0)} success=${Number(d.success || 0)} blocked=${Number(d.blocked || 0)} error=${Number(d.error || 0)} retries=${Number(d.retryAttempts || 0)} recovered=${Number(d.retryRecovered || 0)} lastErr=${d.lastErrorCode || '-'}(${d.lastErrorCategory || '-'})`;
        return `Runs: ${total} Â· Success: ${success} Â· Failed: ${failed} Â· Rollback: ${rollback} Â· Reconcile warns: ${reconcileWarn} Â· Success rate: ${successRate.toFixed(1)}% Â· ${latestText} Â· ${pnlText} Â· ${rpcText} Â· ${rpcDetail} Â· ${topText} Â· ${webhookText} Â· ${debridgeText}`;
      }

      function getDebridgeWindowErrorStats(snapshot, windowKey = "24h") {
        const d = snapshot?.debridgeExecuteMetrics || {};
        const now = Date.now();
        const windowMs = windowKey === "1h"
          ? 60 * 60 * 1000
          : windowKey === "7d"
            ? 7 * 24 * 60 * 60 * 1000
            : 24 * 60 * 60 * 1000;
        const recent = Array.isArray(d.recent) ? d.recent : [];
        const rows = recent.filter((r) => {
          const ts = Date.parse(String(r?.timestamp || ""));
          return Number.isFinite(ts) && now - ts <= windowMs;
        });
        const buckets = rows
          .filter((r) => String(r?.status || "") === "error")
          .reduce((acc, r) => {
            const key = String(r?.errorCode || "unknown");
            acc[key] = (acc[key] || 0) + 1;
            return acc;
          }, {});
        const entries = Object.entries(buckets).sort((a, b) => b[1] - a[1]);
        return {
          rows,
          topEntries: entries,
          dominantError: entries[0]?.[0] || null,
        };
      }

      function debridgeImmediateActionHint(priority, dominantError) {
        if (priority !== "focused-fix") return "";
        const code = String(dominantError || "");
        if (code === "debridge_execute_timeout") return "ðŸš¨ Immediate action: increase timeout and reduce route complexity for next run.";
        if (code === "debridge_execute_rate_limited") return "ðŸš¨ Immediate action: throttle trigger frequency and increase retry backoff.";
        if (code === "debridge_execute_network_error") return "ðŸš¨ Immediate action: verify MCP host network/DNS health before next execute.";
        if (code === "debridge_execute_insufficient_funds") return "ðŸš¨ Immediate action: top up gas/token balance before re-execution.";
        if (code === "debridge_execute_invalid_request") return "ðŸš¨ Immediate action: re-run plan/quote and validate execute params.";
        if (code === "debridge_execute_unauthorized") return "ðŸš¨ Immediate action: disable execute and rotate/repair credentials.";
        return "ðŸš¨ Immediate action: inspect raw output + artifact and pause aggressive retries.";
      }

      function computeDebridgeReliability(snapshot, windowKey = "24h") {
        const d = snapshot?.debridgeExecuteMetrics || {};
        const total = Number(d.total || 0);
        if (total <= 0) return "No deBridge execute telemetry yet.";
        const success = Number(d.success || 0);
        const blocked = Number(d.blocked || 0);
        const error = Number(d.error || 0);
        const retries = Number(d.retryAttempts || 0);
        const recovered = Number(d.retryRecovered || 0);
        const successRate = total > 0 ? (success / total) * 100 : 0;
        const recoveryRate = retries > 0 ? (recovered / retries) * 100 : 0;
        const recent = Array.isArray(d.recent) ? d.recent : [];
        const errorBuckets = recent
          .filter((r) => String(r?.status || "") === "error")
          .reduce((acc, r) => {
            const key = String(r?.errorCode || "unknown");
            acc[key] = (acc[key] || 0) + 1;
            return acc;
          }, {});
        const topErrors = Object.entries(errorBuckets)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([k, v]) => `${k}:${v}`)
          .join(" Â· ") || "-";
        const trend = recent
          .slice(0, 20)
          .map((r) => {
            const s = String(r?.status || "");
            if (s === "success") return "ðŸŸ©";
            if (s === "blocked") return "ðŸŸ¨";
            if (s === "error") return "ðŸŸ¥";
            return "â¬œ";
          })
          .join("");
        const trendLabel = trend || "-";

        const windowStats = getDebridgeWindowErrorStats(snapshot, windowKey);
        const topErrorsWindow = windowStats.topEntries
          .slice(0, 3)
          .map(([k, v]) => `${k}:${v}`)
          .join(" Â· ") || "-";
        const dominantEntry = windowStats.topEntries[0] || null;
        const dominantErrorLabel = dominantEntry?.[0] || "-";
        const totalWindowErrors = windowStats.topEntries.reduce((acc, [, count]) => acc + Number(count || 0), 0);
        const dominantRatio = dominantEntry && totalWindowErrors > 0
          ? ((Number(dominantEntry[1] || 0) / totalWindowErrors) * 100).toFixed(1)
          : "0.0";
        const dominantRatioNum = Number.parseFloat(dominantRatio);
        const priority = dominantRatioNum >= 60
          ? "focused-fix"
          : dominantRatioNum >= 30
            ? "watch"
            : "normal";
        const priorityBadge = priority === "focused-fix"
          ? "ðŸš¨ focused-fix"
          : priority === "watch"
            ? "âš ï¸ watch"
            : "âœ… normal";
        const immediateAction = debridgeImmediateActionHint(priority, dominantErrorLabel);

        const compareWindow = recent.slice(0, 20);
        const half = Math.max(1, Math.floor(compareWindow.length / 2));
        const latestHalf = compareWindow.slice(0, half);
        const prevHalf = compareWindow.slice(half, half * 2);
        const latestRate = latestHalf.length
          ? (latestHalf.filter((r) => String(r?.status || "") === "success").length / latestHalf.length) * 100
          : 0;
        const prevRate = prevHalf.length
          ? (prevHalf.filter((r) => String(r?.status || "") === "success").length / prevHalf.length) * 100
          : 0;
        const delta = latestRate - prevRate;
        const arrow = delta > 0.01 ? "â†‘" : delta < -0.01 ? "â†“" : "â†’";

        return `Total=${total} Â· Success=${success} Â· Blocked=${blocked} Â· Error=${error} Â· SuccessRate=${successRate.toFixed(1)}% Â· RetryAttempts=${retries} Â· RetryRecovered=${recovered} Â· RecoveryRate=${recoveryRate.toFixed(1)}% Â· TopErrors=${topErrors} Â· LastErr=${d.lastErrorCode || "-"}(${d.lastErrorCategory || "-"})\nRecent(20): ${trendLabel}\n${windowKey} TopErrors: ${topErrorsWindow}\n${windowKey} DominantError: ${dominantErrorLabel} (${dominantRatio}% of window errors) Â· priority=${priorityBadge}\n${immediateAction ? `${immediateAction}\n` : ""}Success trend: ${arrow} ${latestRate.toFixed(1)}% vs ${prevRate.toFixed(1)}% (Î” ${delta >= 0 ? "+" : ""}${delta.toFixed(1)}pp)`;
      }

      function debridgeSuggestedActionsFromTopErrors(errors) {
        const actions = [];
        for (const [code] of errors) {
          if (code === "debridge_execute_timeout") actions.push("Increase DEBRIDGE_MCP_TIMEOUT_MS or lower route complexity/amount.");
          else if (code === "debridge_execute_rate_limited") actions.push("Add backoff and reduce trigger rate; review provider/API quota.");
          else if (code === "debridge_execute_network_error") actions.push("Check MCP host network/DNS and retry policy settings.");
          else if (code === "debridge_execute_insufficient_funds") actions.push("Top up source wallet and verify gas + token balances.");
          else if (code === "debridge_execute_invalid_request") actions.push("Validate token/chain/amount params against deBridge route constraints.");
          else if (code === "debridge_execute_unauthorized") actions.push("Re-check credentials/permissions for deBridge MCP execute lane.");
        }
        if (actions.length === 0) actions.push("No immediate fix hints; inspect rawOutput + executionArtifact for edge-case failures.");
        return actions.slice(0, 3);
      }

      function buildDebridgeQuickFixSnippet(code) {
        const key = String(code || "");
        if (key === "debridge_execute_timeout") {
          return [
            "# quick fix: timeout",
            "export DEBRIDGE_MCP_TIMEOUT_MS=180000",
          ].join("\n");
        }
        if (key === "debridge_execute_rate_limited") {
          return [
            "# quick fix: rate limit",
            "export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=3",
            "export DEBRIDGE_MCP_EXECUTE_RETRY_BACKOFF_MS=2500",
          ].join("\n");
        }
        if (key === "debridge_execute_network_error") {
          return [
            "# quick fix: network",
            "export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=3",
            "export DEBRIDGE_MCP_EXECUTE_RETRY_BACKOFF_MS=2000",
          ].join("\n");
        }
        if (key === "debridge_execute_insufficient_funds") {
          return [
            "# quick fix: insufficient funds",
            "# top up gas + source token balance before retry",
            "export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=1",
          ].join("\n");
        }
        if (key === "debridge_execute_invalid_request") {
          return [
            "# quick fix: invalid request",
            "# verify origin/destination/tokenIn/tokenOut/amount",
            "export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=1",
          ].join("\n");
        }
        if (key === "debridge_execute_unauthorized") {
          return [
            "# quick fix: unauthorized",
            "export DEBRIDGE_MCP_EXECUTE_ENABLED=false",
            "# re-enable after credential validation",
          ].join("\n");
        }
        return [
          "# quick fix: generic",
          "export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=2",
          "export DEBRIDGE_MCP_EXECUTE_RETRY_BACKOFF_MS=1500",
        ].join("\n");
      }

      function appendDebridgeQuickFixToConsole(code) {
        const snippet = buildDebridgeQuickFixSnippet(code);
        if (cmdOutEl) {
          const prev = String(cmdOutEl.value || "").trim();
          cmdOutEl.value = prev ? `${prev}\n\n${snippet}` : snippet;
        }
      }

      function buildDebridgeFixDraft(snapshot, windowKey = "24h") {
        const d = snapshot?.debridgeExecuteMetrics || {};
        const windowStats = getDebridgeWindowErrorStats(snapshot, windowKey);
        const topCode = windowStats.dominantError || "";
        const code = String(topCode || d.lastErrorCode || "");
        const lines = [
          "# deBridge fix draft",
          "# Apply to shell env or dashboard config",
          `# window=${windowKey}`,
          `# dominantError=${code || "-"}`,
          "",
        ];
        if (code === "debridge_execute_timeout") {
          lines.push("export DEBRIDGE_MCP_TIMEOUT_MS=180000");
          lines.push("# optional: reduce route amount / complexity for validation run");
        } else if (code === "debridge_execute_rate_limited") {
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=3");
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_BACKOFF_MS=2500");
          lines.push("# optional: reduce schedule trigger frequency");
        } else if (code === "debridge_execute_network_error") {
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=3");
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_BACKOFF_MS=2000");
          lines.push("# verify MCP host DNS/network stability");
        } else if (code === "debridge_execute_insufficient_funds") {
          lines.push("# top up gas + source token balance first");
          lines.push("# keep retries conservative to avoid waste");
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=1");
        } else if (code === "debridge_execute_invalid_request") {
          lines.push("# validate route params: origin/destination/tokenIn/tokenOut/amount");
          lines.push("# run /api/crosschain/debridge/plan then /quote before execute");
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=1");
        } else if (code === "debridge_execute_unauthorized") {
          lines.push("# verify execute credentials/permissions for deBridge MCP");
          lines.push("export DEBRIDGE_MCP_EXECUTE_ENABLED=false");
          lines.push("# re-enable after credential validation");
        } else {
          lines.push("# generic safe defaults");
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_MAX_ATTEMPTS=2");
          lines.push("export DEBRIDGE_MCP_EXECUTE_RETRY_BACKOFF_MS=1500");
        }
        lines.push("");
        lines.push(`# lastErrorCode=${code || "-"}`);
        lines.push(`# lastErrorCategory=${String(d.lastErrorCategory || "-")}`);
        lines.push(`# lastErrorAt=${String(d.lastErrorAt || "-")}`);
        return lines.join("\n");
      }

      function buildDebridgeIncidentSummary(snapshot, windowKey = "24h") {
        const d = snapshot?.debridgeExecuteMetrics || {};
        const now = Date.now();
        const windowMs = windowKey === "1h"
          ? 60 * 60 * 1000
          : windowKey === "7d"
            ? 7 * 24 * 60 * 60 * 1000
            : 24 * 60 * 60 * 1000;
        const recent = Array.isArray(d.recent) ? d.recent : [];
        const rows = recent.filter((r) => {
          const ts = Date.parse(String(r?.timestamp || ""));
          return Number.isFinite(ts) && now - ts <= windowMs;
        });
        const total = rows.length;
        const success = rows.filter((r) => String(r?.status || "") === "success").length;
        const blocked = rows.filter((r) => String(r?.status || "") === "blocked").length;
        const error = rows.filter((r) => String(r?.status || "") === "error").length;
        const successRate = total > 0 ? (success / total) * 100 : 0;
        const errorBuckets = rows
          .filter((r) => String(r?.status || "") === "error")
          .reduce((acc, r) => {
            const key = String(r?.errorCode || "unknown");
            acc[key] = (acc[key] || 0) + 1;
            return acc;
          }, {});
        const topErrorEntries = Object.entries(errorBuckets)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);
        const dominantEntry = topErrorEntries[0] || null;
        const totalErrorCount = topErrorEntries.reduce((acc, [, n]) => acc + Number(n || 0), 0);
        const dominantRatio = dominantEntry && totalErrorCount > 0
          ? ((Number(dominantEntry[1] || 0) / totalErrorCount) * 100).toFixed(1)
          : "0.0";
        const dominantRatioNum = Number.parseFloat(dominantRatio);
        const priority = dominantRatioNum >= 60
          ? "focused-fix"
          : dominantRatioNum >= 30
            ? "watch"
            : "normal";
        const priorityBadge = priority === "focused-fix"
          ? "ðŸš¨ focused-fix"
          : priority === "watch"
            ? "âš ï¸ watch"
            : "âœ… normal";
        const immediateAction = debridgeImmediateActionHint(priority, dominantEntry?.[0] || "");
        const topErrors = topErrorEntries
          .map(([k, v]) => `- ${k}: ${v}`)
          .join("\n") || "- none";
        const suggestedActions = debridgeSuggestedActionsFromTopErrors(topErrorEntries)
          .map((x, i) => `${i + 1}. ${x}`)
          .join("\n");
        const trend = rows
          .slice(0, 20)
          .map((r) => {
            const s = String(r?.status || "");
            if (s === "success") return "ðŸŸ©";
            if (s === "blocked") return "ðŸŸ¨";
            if (s === "error") return "ðŸŸ¥";
            return "â¬œ";
          })
          .join("") || "-";
        return [
          `[deBridge Incident Summary]`,
          `window: ${windowKey}`,
          `generatedAt: ${new Date().toISOString()}`,
          `totals: total=${total} success=${success} blocked=${blocked} error=${error}`,
          `successRate: ${successRate.toFixed(1)}%`,
          `retryStats: attempts=${Number(d.retryAttempts || 0)} recovered=${Number(d.retryRecovered || 0)}`,
          `lastError: ${d.lastErrorCode || "-"} (${d.lastErrorCategory || "-"}) at ${d.lastErrorAt || "-"}`,
          `topErrors:`,
          topErrors,
          `dominantError: ${dominantEntry?.[0] || "-"} (${dominantRatio}% of window errors)`,
          `priority: ${priorityBadge}`,
          `immediateAction: ${immediateAction || "-"}`,
          `recentTrend(20): ${trend}`,
          `conclusion: ${error > success ? "degraded" : error > 0 ? "warning" : "healthy"}`,
          `nextActions:\n${suggestedActions}`,
        ].join("\n");
      }

      function toCsv(snapshot) {
        const lines = [
          ["section", "key", "value"],
          ["meta", "accountId", snapshot.accountId],
          ["meta", "updatedAt", snapshot.updatedAt],
          ["near", "available", snapshot.near.available],
          ["near", "locked", snapshot.near.locked],
        ];
        for (const row of snapshot.tokens || []) {
          lines.push(["token", row.symbol, row.amount]);
        }
        for (const row of snapshot.burrow?.collateral || []) {
          lines.push(["burrow_collateral", row.symbol, row.amount]);
        }
        return lines.map((cols) => cols.map((c) => `"${String(c).replaceAll('"', '""')}"`).join(",")).join("\n");
      }

      let lastSnapshot = null;
      let lastRebalancePlan = null;
      let lastAcpAsyncJobId = "";
      const BSC_READINESS_PROTOCOL_KEY = "near_dashboard.bsc.readinessProtocol";
      const DEBRIDGE_WINDOW_KEY = "near_dashboard.debridge.window";
      let targetConfig = loadTargets();
      targetUsdtEl.value = targetConfig.usdt;
      targetUsdceEl.value = targetConfig.usdce;
      targetThresholdEl.value = targetConfig.threshold;
      if (bscExecutionProtocolEl) {
        const savedProtocol = String(localStorage.getItem(BSC_READINESS_PROTOCOL_KEY) || "aave").toLowerCase();
        const allowed = ["aave", "lista", "wombat", "venus"];
        bscExecutionProtocolEl.value = allowed.includes(savedProtocol) ? savedProtocol : "aave";
      }
      if (strategyDslInputEl && !strategyDslInputEl.value) {
        strategyDslInputEl.value = JSON.stringify(buildStrategyDslSample(), null, 2);
      }
      if (debridgeWindowEl) {
        const savedDebridgeWindow = String(localStorage.getItem(DEBRIDGE_WINDOW_KEY) || "24h").toLowerCase();
        const allowedDebridgeWindows = ["1h", "24h", "7d"];
        debridgeWindowEl.value = allowedDebridgeWindows.includes(savedDebridgeWindow)
          ? savedDebridgeWindow
          : "24h";
      }

      function buildStrategyDslSample() {
        return {
          dsl: {
            id: "stable-rebalance-near-v1",
            name: "Stable Rebalance NEAR",
            creator: currentAccount(),
            version: "1.0.0",
            targetChain: "near",
            intentType: "rebalance.usdt_to_usdce",
            pricing: {
              priceUsd: 9.9,
              currency: "USDC",
            },
            risk: {
              maxAmountUsd: 100,
              maxSlippageBps: 80,
              dailyRunLimit: 3,
            },
            execution: {
              mode: "plan-only",
            },
            inputs: {
              tokenIn: "USDt",
              tokenOut: "USDC.e",
            },
          },
        };
      }

      async function load() {
        const accountId = accountInput.value.trim();
        const query = accountId ? `?accountId=${encodeURIComponent(accountId)}` : "";
        const selectedProtocol = String(bscExecutionProtocolEl?.value || "aave").toLowerCase();
        const [snapRes, unifiedRes, bscYieldPlanRes, bscYieldMarketsRes, acpStatusRes, acpSummaryRes, acpJobsRes, paymentsRes, acpDeadRes, acpDismissedRes] = await Promise.all([
          fetch(`/api/snapshot${query}`),
          fetch(`/api/portfolio/unified${query}`),
          fetch(`/api/bsc/yield/plan${query ? `${query}&executionProtocol=${encodeURIComponent(selectedProtocol)}` : `?executionProtocol=${encodeURIComponent(selectedProtocol)}`}`),
          fetch(`/api/bsc/yield/markets${query || ""}`),
          fetch("/api/acp/status"),
          fetch("/api/acp/jobs/summary"),
          fetch("/api/acp/jobs"),
          fetch("/api/payments"),
          fetch("/api/acp/jobs/dead-letter"),
          fetch("/api/acp/jobs/dismissed"),
        ]);
        const data = await snapRes.json();
        const unified = await unifiedRes.json().catch(() => ({ ok: false }));
        const bscYieldPlan = await bscYieldPlanRes.json().catch(() => ({ ok: false }));
        const bscYieldMarkets = await bscYieldMarketsRes.json().catch(() => ({ ok: false }));
        const acpStatus = await acpStatusRes.json().catch(() => ({ ok: false }));
        const acpSummary = await acpSummaryRes.json().catch(() => ({ ok: false }));
        const acpJobs = await acpJobsRes.json().catch(() => ({ ok: false, jobs: [] }));
        const payments = await paymentsRes.json().catch(() => ({ ok: false, payments: [] }));
        const acpDead = await acpDeadRes.json().catch(() => ({ ok: false, deadLetters: [] }));
        const acpDismissed = await acpDismissedRes.json().catch(() => ({ ok: false, dismissed: [] }));
        if (!snapRes.ok) {
          metaEl.textContent = `Error: ${data.error || "Unknown"}`;
          return;
        }

        lastSnapshot = data;
        accountInput.value = data.accountId;
        metaEl.textContent = `Updated: ${new Date(data.updatedAt).toLocaleString()} Â· RPC: ${data.rpcUrl}`;
        nearEl.innerHTML = `${data.near.available} NEAR <span class="muted">(~$${data.near.usd.toFixed(2)})</span><br/><span class="muted">locked: ${data.near.locked}</span>`;

        burrowRegEl.innerHTML = data.burrow.registered ? `<span class="ok">Registered</span>` : `<span class="warn">Not registered</span>`;
        burrowPosEl.innerHTML = `Collateral: ${rowsToText(data.burrow.collateral)}<br/>Supplied: ${rowsToText(data.burrow.supplied)}<br/>Borrowed: ${rowsToText(data.burrow.borrowed)}`;
        const yieldHealthText = computeYieldHealth(data);
        const aggregateRisk = bscYieldMarkets?.aggregateRisk || {};
        const aggregateBand = String(aggregateRisk?.band || "unknown");
        const aggregateCls = aggregateBand === "high" ? "warn" : aggregateBand === "medium" ? "muted" : aggregateBand === "low" ? "ok" : "muted";
        const aggregateAvg = Number.isFinite(Number(aggregateRisk?.avgScore)) ? Number(aggregateRisk.avgScore) : null;
        const aggregateMax = Number.isFinite(Number(aggregateRisk?.maxScore)) ? Number(aggregateRisk.maxScore) : null;
        yieldHealthEl.innerHTML = `Portfolio aggregate risk: <span class="${aggregateCls}">${aggregateBand}</span> Â· avg=${aggregateAvg != null ? aggregateAvg : "-"} Â· max=${aggregateMax != null ? aggregateMax : "-"}<br/><span class="muted">${yieldHealthText}</span>`;
        execQualityEl.textContent = computeExecutionQuality(data);
        debridgeReliabilityEl.textContent = computeDebridgeReliability(
          data,
          String(debridgeWindowEl?.value || "24h"),
        );
        const bscLayer = (unified?.portfolio?.executionLayers || []).find((x) => String(x?.chain || "").toLowerCase() === "bsc");
        const protocolPos = bscLayer?.positions?.protocols || {};
        const normalizationHealth = bscLayer?.positions?.normalizationHealth || {};
        const sub = protocolPos?.subtotalsUsdApprox || {};
        const health = protocolPos?.health || { status: bscLayer?.status || "unknown", reason: bscLayer?.note || "-", detail: "-" };
        const fetchedAt = protocolPos?.fetchedAt ? new Date(protocolPos.fetchedAt).toLocaleString() : "-";
        const normSources = protocolPos?.normalizationSources || {};
        const listaNorm = normSources?.lista || {};
        const wombatNorm = normSources?.wombat || {};
        const listaNormSource = String(listaNorm?.source || "-");
        const wombatNormSource = String(wombatNorm?.source || "-");
        const listaNormUpdated = listaNorm?.updatedAt ? new Date(listaNorm.updatedAt).toLocaleString() : "-";
        const wombatNormUpdated = wombatNorm?.updatedAt ? new Date(wombatNorm.updatedAt).toLocaleString() : "-";
        const listaNormTitle = `lista source=${listaNormSource} updated=${listaNormUpdated} usdc=${Number(listaNorm?.usdc || 1).toFixed(6)} usdt=${Number(listaNorm?.usdt || 1).toFixed(6)}`;
        const wombatNormTitle = `wombat source=${wombatNormSource} updated=${wombatNormUpdated} usdc=${Number(wombatNorm?.usdc || 1).toFixed(6)} usdt=${Number(wombatNorm?.usdt || 1).toFixed(6)}`;
        const normStatus = String(normalizationHealth?.status || "unknown");
        const normBand = String(normalizationHealth?.band || "unknown");
        const normMaxRisk = Number.isFinite(Number(normalizationHealth?.maxRiskScore)) ? Number(normalizationHealth.maxRiskScore) : "-";
        const normStale = Number(normalizationHealth?.staleCount || 0);
        const normUnknown = Number(normalizationHealth?.unknownCount || 0);
        const normCls = normStatus === "ok" ? "ok" : normStatus === "warn" ? "warn" : "muted";
        bscProtocolHealthEl.innerHTML = `BSC protocol: <span class="${health.status === "ok" ? "ok" : health.status === "error" ? "warn" : "muted"}">${health.status || "unknown"}</span> Â· reason=${health.reason || "-"} Â· detail=${health.detail || "-"}<br/><span class="muted">Aaveâ‰ˆ$${Number(sub.aave || 0).toFixed(2)} Â· Venusâ‰ˆ$${Number(sub.venus || 0).toFixed(2)} Â· Listaâ‰ˆ$${Number(sub.lista || 0).toFixed(2)} Â· Wombatâ‰ˆ$${Number(sub.wombat || 0).toFixed(2)} Â· Totalâ‰ˆ$${Number(protocolPos.totalUsdApprox || 0).toFixed(2)} Â· fetched=${fetchedAt}</span><br/><span class="muted">normalization: <span title="${listaNormTitle}">lista=${listaNormSource}</span> Â· <span title="${wombatNormTitle}">wombat=${wombatNormSource}</span> Â· <span class="${normCls}">health=${normStatus}/${normBand}</span> Â· maxRisk=${normMaxRisk} Â· stale=${normStale} Â· unknown=${normUnknown}</span>`;
        const readiness = bscYieldPlan?.executeReadiness || {};
        const blockers = Array.isArray(readiness?.blockers) ? readiness.blockers : [];
        const blockerText = blockers.length ? blockers.join(", ") : "-";
        const readyClass = readiness?.canExecute === true ? "ok" : "warn";
        const envSnippet = String(readiness?.fixPack?.envLines?.join("\n") || "# no env changes needed\n");
        const fullFixPack = String(readiness?.fixPack?.fullTemplate || "# no full fix pack available\n");
        const blockerPriority = [
          "aave_execute_disabled",
          "missing_bsc_aave_pool",
          "missing_bsc_aave_execute_private_key",
          "missing_bsc_aave_execute_command",
          "bsc_usdc_not_in_aave_allowed_tokens",
          "recommended_amount_exceeds_bsc_aave_max_amount_raw",
          "lista_execute_disabled",
          "missing_bsc_lista_execute_command",
          "bsc_usdc_not_in_lista_allowed_tokens",
          "recommended_amount_exceeds_bsc_lista_max_amount_raw",
          "wombat_execute_disabled",
          "missing_bsc_wombat_execute_command",
          "bsc_usdc_not_in_wombat_allowed_tokens",
          "recommended_amount_exceeds_bsc_wombat_max_amount_raw",
        ];
        const blockerHint = {
          aave_execute_disabled: "Enable gate: BSC_AAVE_EXECUTE_ENABLED=true",
          missing_bsc_aave_pool: "Set BSC_AAVE_POOL",
          missing_bsc_aave_execute_private_key: "Set BSC_AAVE_EXECUTE_PRIVATE_KEY (native mode)",
          missing_bsc_aave_execute_command: "Set BSC_AAVE_EXECUTE_COMMAND (command mode)",
          bsc_usdc_not_in_aave_allowed_tokens: "Include USDC in BSC_AAVE_ALLOWED_TOKENS",
          recommended_amount_exceeds_bsc_aave_max_amount_raw: "Increase BSC_AAVE_MAX_AMOUNT_RAW or lower amount",
          lista_execute_disabled: "Enable gate: BSC_LISTA_EXECUTE_ENABLED=true",
          missing_bsc_lista_execute_command: "Set BSC_LISTA_EXECUTE_COMMAND",
          bsc_usdc_not_in_lista_allowed_tokens: "Include USDC in BSC_LISTA_ALLOWED_TOKENS",
          recommended_amount_exceeds_bsc_lista_max_amount_raw: "Increase BSC_LISTA_MAX_AMOUNT_RAW or lower amount",
          wombat_execute_disabled: "Enable gate: BSC_WOMBAT_EXECUTE_ENABLED=true",
          missing_bsc_wombat_execute_command: "Set BSC_WOMBAT_EXECUTE_COMMAND",
          bsc_usdc_not_in_wombat_allowed_tokens: "Include USDC in BSC_WOMBAT_ALLOWED_TOKENS",
          recommended_amount_exceeds_bsc_wombat_max_amount_raw: "Increase BSC_WOMBAT_MAX_AMOUNT_RAW or lower amount",
        };
        const orderedBlockers = blockers.slice().sort((a, b) => {
          const ia = blockerPriority.indexOf(a);
          const ib = blockerPriority.indexOf(b);
          return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
        });
        const primaryBlocker = orderedBlockers[0] || "-";
        const primaryHint = blockerHint[primaryBlocker] || "-";
        const fixOrderText = orderedBlockers.length
          ? orderedBlockers.map((b, i) => `${i + 1}. ${b}`).join(" | ")
          : "-";
        bscYieldReadinessEl.innerHTML = `BSC execute readiness(${selectedProtocol}): <span class="${readyClass}">${readiness?.canExecute === true ? "ready" : "blocked"}</span> Â· reason=${readiness?.reason || "-"} Â· mode=${readiness?.aaveMode || (selectedProtocol === "venus" ? "native-path" : "command") || "-"}<br/><span class="muted">recommendedProtocol=${readiness?.recommendedProtocol || bscYieldPlan?.netYieldInsight?.netYieldDelta?.preferredProtocol || "-"} Â· blockers=${blockerText}</span><br/><span class="${readiness?.canExecute === true ? "ok" : "warn"}">primary=${primaryBlocker}</span> <span class="muted">hint=${primaryHint}</span><br/><span class="muted">fix-order=${fixOrderText}</span><br/><span class="muted"><button data-copy-blockers="1">Copy blockers</button> <button data-copy-env-snippet="1">Copy env snippet</button> <button data-copy-full-fix-pack="1">Copy full fix pack</button></span>`;
        const copyBlockersBtn = bscYieldReadinessEl.querySelector('[data-copy-blockers="1"]');
        const copyEnvBtn = bscYieldReadinessEl.querySelector('[data-copy-env-snippet="1"]');
        const copyFullFixPackBtn = bscYieldReadinessEl.querySelector('[data-copy-full-fix-pack="1"]');
        copyBlockersBtn?.addEventListener("click", async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          try {
            await navigator.clipboard.writeText(blockers.join("\n") || "-");
            cmdMetaEl.textContent = "Copied blockers";
          } catch {
            cmdMetaEl.textContent = "Copy blockers failed";
          }
        });
        copyEnvBtn?.addEventListener("click", async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          try {
            await navigator.clipboard.writeText(envSnippet);
            cmdMetaEl.textContent = "Copied env snippet";
          } catch {
            cmdMetaEl.textContent = "Copy env snippet failed";
          }
        });
        copyFullFixPackBtn?.addEventListener("click", async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          try {
            await navigator.clipboard.writeText(fullFixPack);
            cmdMetaEl.textContent = "Copied full fix pack";
          } catch {
            cmdMetaEl.textContent = "Copy full fix pack failed";
          }
        });
        const marketHealth = bscYieldMarkets?.marketHealth || {};
        const marketRiskTags = bscYieldMarkets?.marketRiskTags || {};
        const marketRiskScore = bscYieldMarkets?.marketRiskScore || {};
        const marketRiskBand = bscYieldMarkets?.marketRiskBand || {};
        const protocols = ["venus", "aave", "lista", "wombat"];
        const marketHealthText = protocols
          .map((p) => {
            const row = marketHealth?.[p] || {};
            const status = String(row?.status || "unknown");
            const ageMin = Number.isFinite(Number(row?.ageMs)) ? Math.round(Number(row.ageMs) / 60000) : null;
            const cls = status === "fresh" ? "ok" : status === "stale" ? "warn" : "muted";
            const source = String(row?.source || "-");
            const updatedAt = row?.updatedAt ? new Date(row.updatedAt).toLocaleString() : "-";
            const tags = Array.isArray(marketRiskTags?.[p]) ? marketRiskTags[p].join(",") : "-";
            const riskScore = Number.isFinite(Number(marketRiskScore?.[p])) ? Number(marketRiskScore[p]) : null;
            const riskBand = String(marketRiskBand?.[p] || "unknown");
            const riskCls = riskBand === "high" ? "warn" : riskBand === "medium" ? "muted" : riskBand === "low" ? "ok" : "muted";
            const title = `${p} source=${source} updated=${updatedAt} ageMin=${ageMin != null ? ageMin : "-"} tags=${tags} riskScore=${riskScore != null ? riskScore : "-"} riskBand=${riskBand}`;
            return `<span class="${cls}" title="${title}">${p}:${status}${ageMin != null ? `(${ageMin}m)` : ""} <span class="${riskCls}">${riskScore != null ? `r${riskScore}` : "r-"}/${riskBand}</span></span>`;
          })
          .join(" Â· ");
        bscMarketHealthEl.innerHTML = `BSC market health: ${marketHealthText || "<span class=\"muted\">-</span>"}`;
        const acpOk = acpStatus?.ok ? "ok" : "warn";
        const who = acpStatus?.whoami?.name || acpStatus?.whoami?.agentName || "-";
        const totalJobs = Number(acpSummary?.summary?.total || 0);
        const byStatus = acpSummary?.summary?.byStatus || {};
        const daily = acpSummary?.summary?.dailyState || {};
        const dailyLimit = Number(acpSummary?.summary?.policyDailyLimit || 0);
        const queueRows = Array.isArray(acpJobs?.queue) ? acpJobs.queue : [];
        const queueStats = queueRows.reduce((acc, row) => {
          const k = String(row?.status || "unknown");
          acc[k] = (acc[k] || 0) + 1;
          return acc;
        }, {});
        acpOpsEl.innerHTML = `<span class="${acpOk}">${acpStatus?.ok ? "connected" : "not connected"}</span> Â· agent=${who}<br/><span class="muted">jobs=${totalJobs} byStatus=${JSON.stringify(byStatus)} daily=${Number(daily.dailyCount || 0)}/${dailyLimit || "-"} queue=${JSON.stringify(queueStats)}</span>`;
        acpJobsEl.innerHTML = "";
        const statusFilter = (acpStatusFilterEl?.value || "all").trim();
        const buyerFilter = String(acpBuyerFilterEl?.value || "").trim().toLowerCase();
        const strategyFilter = String(acpStrategyFilterEl?.value || "").trim().toLowerCase();
        const onlyFailed = !!acpOnlyFailedEl?.checked;
        const phaseFilter = (acpPhaseFilterEl?.value || "all").trim();
        const detectPhase = (row) => {
          const p = String(row?.postActionStatus || "").toLowerCase();
          const it = String(row?.intentType || "").toLowerCase();
          const err = String(row?.error || "").toLowerCase();
          if (p === "success" || p === "error" || it.includes("bsc_stable_yield") || err.includes("bsc_aave_post_action_failed")) return "bsc-aave-post";
          return "main";
        };
        const filteredJobs = (acpJobs?.jobs || [])
          .filter((row) => statusFilter === "all" || String(row?.status || "") === statusFilter)
          .filter((row) => !buyerFilter || String(row?.buyer || "").toLowerCase().includes(buyerFilter))
          .filter((row) => !strategyFilter || String(row?.strategyId || "").toLowerCase().includes(strategyFilter))
          .filter((row) => !onlyFailed || ["error", "blocked"].includes(String(row?.status || "").toLowerCase()))
          .filter((row) => phaseFilter === "all" || detectPhase(row) === phaseFilter)
          .slice(0, 20);
        for (const row of filteredJobs) {
          const tr = document.createElement("tr");
          let tx = "-";
          if (row.txHash) {
            if (String(row.targetChain || "").toLowerCase() === "near") {
              const href = `https://explorer.near.org/transactions/${row.txHash}`;
              tx = `<a href="${href}" target="_blank" rel="noreferrer">${row.txHash}</a>`;
            } else {
              tx = row.txHash;
            }
          }
          const protocol = row.executionProtocol || "-";
          const postActionStatus = row.postActionStatus || "-";
          tr.innerHTML = `<td>${new Date(row.timestamp).toLocaleString()}</td><td>${row.runId || "-"}</td><td>${row.status || "-"}</td><td>${row.targetChain || "-"}</td><td>${row.intentType || "-"}</td><td>${protocol}</td><td>${postActionStatus}</td><td>${row.strategyId || "-"}</td><td>${row.buyer || "-"}</td><td>${row.remainingUses ?? "-"}</td><td>${row.amountRaw || "-"}</td><td>${tx}</td>`;
          tr.style.cursor = "pointer";
          tr.title = "Click to expand job details";

          const detailTr = document.createElement("tr");
          detailTr.style.display = "none";
          const detailTd = document.createElement("td");
          detailTd.colSpan = 12;
          const detailJson = JSON.stringify(row, null, 2);
          const detailTxHash = String(row.txHash || "").trim();
          const detailChain = String(row.targetChain || "").toLowerCase();
          const detailExplorer = detailTxHash
            ? detailChain === "near"
              ? `https://explorer.near.org/transactions/${detailTxHash}`
              : detailChain === "bsc"
                ? `https://bscscan.com/tx/${detailTxHash}`
                : ""
            : "";
          const detailReceipt = row.receipt ? JSON.stringify(row.receipt, null, 2) : "-";
          const detailResult = row.result ? JSON.stringify(row.result, null, 2) : "-";
          const detailError = row.error ? JSON.stringify(row.error, null, 2) : "-";
          const hasError = String(row.status || "").toLowerCase() === "error" || !!row.error;
          const expandErrorBlocks = !!acpExpandErrorsEl?.checked && hasError;
          detailTd.innerHTML = `<div class="row" style="margin-bottom:6px"><button data-copy-json="1">Copy JSON</button><button data-copy-run="1">Copy runId/jobId</button><button data-copy-tx="1">Copy txHash</button><button data-open-explorer="1">Open explorer</button><span class="muted" data-copy-meta="1"></span></div><details style="margin:4px 0" ${expandErrorBlocks ? "open" : ""}><summary>receipt</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailReceipt}</pre></details><details style="margin:4px 0" ${expandErrorBlocks ? "open" : ""}><summary>result</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailResult}</pre></details><details style="margin:4px 0" ${expandErrorBlocks ? "open" : ""}><summary>${hasError ? "âš  error" : "error"}</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailError}</pre></details><details style="margin:4px 0"><summary>raw</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailJson}</pre></details>`;
          detailTr.appendChild(detailTd);

          const copyJsonBtn = detailTd.querySelector('[data-copy-json="1"]');
          const copyRunBtn = detailTd.querySelector('[data-copy-run="1"]');
          const copyTxBtn = detailTd.querySelector('[data-copy-tx="1"]');
          const openExplorerBtn = detailTd.querySelector('[data-open-explorer="1"]');
          const copyMetaEl = detailTd.querySelector('[data-copy-meta="1"]');
          copyJsonBtn?.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            try {
              await navigator.clipboard.writeText(detailJson);
              if (copyMetaEl) copyMetaEl.textContent = "JSON copied";
            } catch {
              if (copyMetaEl) copyMetaEl.textContent = "Copy JSON failed";
            }
          });
          copyRunBtn?.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            const token = String(row.runId || row.jobId || row.id || "");
            if (!token) {
              if (copyMetaEl) copyMetaEl.textContent = "No runId/jobId";
              return;
            }
            try {
              await navigator.clipboard.writeText(token);
              if (copyMetaEl) copyMetaEl.textContent = `Copied: ${token}`;
            } catch {
              if (copyMetaEl) copyMetaEl.textContent = "Copy runId/jobId failed";
            }
          });
          copyTxBtn?.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            if (!detailTxHash) {
              if (copyMetaEl) copyMetaEl.textContent = "No txHash";
              return;
            }
            try {
              await navigator.clipboard.writeText(detailTxHash);
              if (copyMetaEl) copyMetaEl.textContent = `txHash copied: ${detailTxHash}`;
            } catch {
              if (copyMetaEl) copyMetaEl.textContent = "Copy txHash failed";
            }
          });
          openExplorerBtn?.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (!detailExplorer) {
              if (copyMetaEl) copyMetaEl.textContent = "No explorer URL for this chain/tx";
              return;
            }
            window.open(detailExplorer, "_blank", "noopener,noreferrer");
            if (copyMetaEl) copyMetaEl.textContent = "Explorer opened";
          });

          tr.addEventListener("click", () => {
            detailTr.style.display = detailTr.style.display === "none" ? "table-row" : "none";
          });

          acpJobsEl.appendChild(tr);
          acpJobsEl.appendChild(detailTr);
        }
        if (lastAcpAsyncJobId) {
          const inQueue = (acpJobs?.queue || []).find((x) => String(x?.jobId || "") === String(lastAcpAsyncJobId));
          if (inQueue) {
            acpAsyncStatusEl.textContent = `job=${inQueue.jobId} status=${inQueue.status} updated=${inQueue.updatedAt || "-"}${inQueue.error ? ` error=${inQueue.error}` : ""}`;
          }
        }
        const classifyPhase = (row) => {
          const p = String(row?.postActionStatus || "").toLowerCase();
          const it = String(row?.intentType || "").toLowerCase();
          const err = String(row?.error || "").toLowerCase();
          if (p === "success" || p === "error" || it.includes("bsc_stable_yield") || err.includes("bsc_aave_post_action_failed")) return "bsc-aave-post";
          return "main";
        };
        const classifyErrorType = (row) => {
          const t = String(row?.errorType || "").trim();
          if (t) return t;
          const err = String(row?.error || "").toLowerCase();
          if (err.includes("bsc_aave_post_action_failed")) return "bsc_aave_post_action_failed";
          if (err.includes("bsc_execute_config")) return "bsc_execute_config";
          if (err.includes("bsc_execute_failed")) return "bsc_execute_failed";
          if (err.includes("timeout")) return "timeout";
          if (err.includes("429") || err.includes("too many requests")) return "rpc_429";
          return "unknown";
        };

        const heatmapWindow = String(acpHeatmapWindowEl?.value || "24h").trim();
        const windowMs = heatmapWindow === "1h"
          ? 60 * 60 * 1000
          : heatmapWindow === "7d"
            ? 7 * 24 * 60 * 60 * 1000
            : 24 * 60 * 60 * 1000;
        const windowStart = Date.now() - windowMs;
        const failureRows = (acpJobs?.jobs || []).filter((row) => {
          const ts = Date.parse(String(row?.timestamp || ""));
          if (!Number.isFinite(ts) || ts < windowStart) return false;
          return ["error", "blocked"].includes(String(row?.status || "").toLowerCase());
        });
        const heatmap = {};
        for (const row of failureRows) {
          const phase = classifyPhase(row);
          const type = classifyErrorType(row);
          if (!heatmap[phase]) heatmap[phase] = {};
          heatmap[phase][type] = (heatmap[phase][type] || 0) + 1;
        }
        const heatmapEntries = Object.entries(heatmap)
          .flatMap(([phase, byType]) => Object.entries(byType).map(([type, cnt]) => ({ phase, type, cnt })))
          .sort((a, b) => b.cnt - a.cnt)
          .slice(0, 8);
        const normRows = Array.isArray(normalizationHealth?.topRows) ? normalizationHealth.topRows : [];
        const normBand = String(normalizationHealth?.band || "unknown");
        const normStatus = String(normalizationHealth?.status || "unknown");
        const normChips = normRows
          .map((row) => {
            const protocol = String(row?.protocol || "-");
            const freshness = String(row?.freshness || "unknown");
            const source = String(row?.source || "unknown");
            const ageMin = Number.isFinite(Number(row?.ageMs)) ? Math.round(Number(row.ageMs) / 60000) : "-";
            return `<button data-norm-chip="1" data-protocol="${protocol}" data-source="${source}" class="muted" style="margin-right:6px">norm/${protocol}:${freshness}@${ageMin}m(${source})</button>`;
          })
          .join("");
        const heatmapCore = heatmapEntries.length > 0
          ? heatmapEntries.map((x) => `<button data-heatmap-chip="1" data-phase="${x.phase}" data-type="${x.type}" class="warn" style="margin-right:6px">${x.phase}/${x.type}:${x.cnt}</button>`).join("")
          : "none";
        acpFailureHeatmapEl.innerHTML = `failure heatmap (${heatmapWindow}): ${heatmapCore}<br/><span class="muted">normRisk=${normStatus}/${normBand} ${normChips}</span>`;
        acpFailureHeatmapEl.querySelectorAll('button[data-heatmap-chip="1"]').forEach((btn) => {
          btn.addEventListener("click", () => {
            const phase = String(btn.getAttribute("data-phase") || "all");
            const type = String(btn.getAttribute("data-type") || "all");
            if (acpDeadPhaseFilterEl) acpDeadPhaseFilterEl.value = phase;
            if (acpDeadTypeFilterEl) acpDeadTypeFilterEl.value = type;
            syncAcpFiltersToUrl();
            load().catch(() => {});
          });
        });
        acpFailureHeatmapEl.querySelectorAll('button[data-norm-chip="1"]').forEach((btn) => {
          btn.addEventListener("click", () => {
            const protocol = String(btn.getAttribute("data-protocol") || "-");
            const source = String(btn.getAttribute("data-source") || "unknown");
            acpAsyncMetaEl.textContent = `Normalization focus: ${protocol} source=${source}. Check bsc.positions.*RateApiUrl and rate freshness.`;
          });
        });

        const deadLetters = Array.isArray(acpDead?.deadLetters) ? acpDead.deadLetters : [];
        const deadPhaseFilter = (acpDeadPhaseFilterEl?.value || "all").trim();
        const deadTypeFilter = (acpDeadTypeFilterEl?.value || "all").trim();
        const classifyDeadPhase = (row) => String(row?.errorType || '').includes('bsc_aave') ? 'bsc-aave-post' : 'main';
        const deadByTypeAll = deadLetters.reduce((acc, row) => {
          const k = String(row?.errorType || 'unknown');
          acc[k] = (acc[k] || 0) + 1;
          return acc;
        }, {});
        if (acpDeadTypeFilterEl) {
          const prev = acpDeadTypeFilterEl.value || "all";
          const options = [`<option value="all">dead-letter type: all</option>`]
            .concat(Object.entries(deadByTypeAll).sort((a,b)=>b[1]-a[1]).map(([k,v]) => `<option value="${k}">${k} (${v})</option>`));
          acpDeadTypeFilterEl.innerHTML = options.join("");
          acpDeadTypeFilterEl.value = deadByTypeAll[prev] || prev === "all" ? prev : "all";
        }
        const filteredDeadLetters = deadLetters
          .filter((row) => deadPhaseFilter === "all" || classifyDeadPhase(row) === deadPhaseFilter)
          .filter((row) => deadTypeFilter === "all" || String(row?.errorType || 'unknown') === deadTypeFilter);
        const dismissedRows = Array.isArray(acpDismissed?.dismissed) ? acpDismissed.dismissed : [];
        acpDeadLettersEl.innerHTML = `dead-letter: ${filteredDeadLetters.length}/${deadLetters.length}`;
        acpDismissedEl.textContent = `dismissed: ${dismissedRows.length}`;
        if (filteredDeadLetters.length > 0) {
          const byType = filteredDeadLetters.reduce((acc, row) => {
            const k = String(row?.errorType || 'unknown');
            acc[k] = (acc[k] || 0) + 1;
            return acc;
          }, {});
          const byTypeChips = Object.entries(byType)
            .sort((a,b)=>b[1]-a[1])
            .map(([k,v]) => {
              const active = deadTypeFilter === k;
              return `<button data-dl-type-chip="${k}" style="margin-right:6px;${active ? 'font-weight:bold;' : ''}">${k} (${v})</button>`;
            }).join("");
          const retryableCount = filteredDeadLetters.filter((row) => !!row?.retryable).length;
          const rowsHtml = filteredDeadLetters.slice(0, 20).map((row) => {
            const jobId = String(row?.jobId || "");
            const err = String(row?.error || "").replace(/</g, "&lt;").slice(0, 120);
            const retryableBadge = row?.retryable ? '<span class="ok">retryable</span>' : '<span class="warn">non-retryable</span>';
            const phase = String(row?.errorType || '').includes('bsc_aave') ? 'bsc-aave-post' : 'main';
            return `<tr><td><input type="checkbox" data-dl-select="${jobId}" /></td><td>${jobId}</td><td>${row.attemptCount || 0}/${row.maxAttempts || 0}</td><td>${row.errorType || '-'}</td><td>${phase}</td><td>${retryableBadge}</td><td>${row.updatedAt || "-"}</td><td class="warn">${err}</td><td><button data-retry-job="${jobId}">Retry</button></td></tr>`;
          }).join("");
          acpDeadLettersEl.innerHTML += `<div class="muted" style="margin-top:4px">byType=${JSON.stringify(byType)} retryable=${retryableCount}/${filteredDeadLetters.length}</div><div style="margin-top:6px">${byTypeChips || ''}</div><div style="margin-top:6px"><button data-dl-retry-retryable="1">Retry retryable only</button> <button data-dl-retry-selected="1">Retry selected</button> <button data-dl-dismiss-selected="1">Dismiss selected</button></div><table style="margin-top:6px"><thead><tr><th></th><th>jobId</th><th>attempts</th><th>type</th><th>phase</th><th>retry</th><th>updated</th><th>error</th><th>action</th></tr></thead><tbody>${rowsHtml}</tbody></table>`;

          acpDeadLettersEl.querySelectorAll("button[data-dl-type-chip]").forEach((btn) => {
            btn.addEventListener("click", () => {
              const t = String(btn.getAttribute("data-dl-type-chip") || "all");
              if (acpDeadTypeFilterEl) acpDeadTypeFilterEl.value = t;
              syncAcpFiltersToUrl();
              load().catch(() => {});
            });
          });

          acpDeadLettersEl.querySelectorAll("button[data-retry-job]").forEach((btn) => {
            btn.addEventListener("click", async (ev) => {
              ev.stopPropagation();
              const jobId = String(btn.getAttribute("data-retry-job") || "");
              if (!jobId) return;
              acpAsyncMetaEl.textContent = `Retrying ${jobId}...`;
              try {
                const res = await fetch("/api/acp/jobs/retry", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ confirm: true, jobId }),
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok) throw new Error(data?.error || `retry failed (${res.status})`);
                acpAsyncMetaEl.textContent = `Retried ${jobId}`;
                await load();
              } catch (e) {
                acpAsyncMetaEl.textContent = `Retry failed: ${e.message || e}`;
              }
            });
          });

          const selectedJobIds = () => Array.from(acpDeadLettersEl.querySelectorAll('input[data-dl-select]:checked'))
            .map((el) => String(el.getAttribute('data-dl-select') || '').trim())
            .filter(Boolean);

          const retryRetryableBtn = acpDeadLettersEl.querySelector('button[data-dl-retry-retryable="1"]');
          retryRetryableBtn?.addEventListener('click', async () => {
            acpAsyncMetaEl.textContent = 'Retrying retryable dead-letter jobs...';
            try {
              const res = await fetch('/api/acp/jobs/retry-retryable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ confirm: true }),
              });
              const data = await res.json().catch(() => ({}));
              if (!res.ok) throw new Error(data?.error || `retry-retryable failed (${res.status})`);
              acpAsyncMetaEl.textContent = `Retried ${Number(data.retriedCount || 0)} retryable job(s)`;
              await load();
            } catch (e) {
              acpAsyncMetaEl.textContent = `Retry retryable failed: ${e.message || e}`;
            }
          });

          const retrySelectedBtn = acpDeadLettersEl.querySelector('button[data-dl-retry-selected="1"]');
          retrySelectedBtn?.addEventListener('click', async () => {
            const jobIds = selectedJobIds();
            if (jobIds.length === 0) {
              acpAsyncMetaEl.textContent = 'No dead-letter jobs selected';
              return;
            }
            acpAsyncMetaEl.textContent = `Retrying ${jobIds.length} dead-letter job(s)...`;
            try {
              const res = await fetch('/api/acp/jobs/retry-batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ confirm: true, jobIds }),
              });
              const data = await res.json().catch(() => ({}));
              if (!res.ok) throw new Error(data?.error || `retry-batch failed (${res.status})`);
              acpAsyncMetaEl.textContent = `Retried ${Array.isArray(data.retried) ? data.retried.length : 0} job(s)`;
              await load();
            } catch (e) {
              acpAsyncMetaEl.textContent = `Retry selected failed: ${e.message || e}`;
            }
          });

          const dismissSelectedBtn = acpDeadLettersEl.querySelector('button[data-dl-dismiss-selected="1"]');
          dismissSelectedBtn?.addEventListener('click', async () => {
            const jobIds = selectedJobIds();
            if (jobIds.length === 0) {
              acpAsyncMetaEl.textContent = 'No dead-letter jobs selected';
              return;
            }
            acpAsyncMetaEl.textContent = `Dismissing ${jobIds.length} dead-letter job(s)...`;
            try {
              const res = await fetch('/api/acp/jobs/dismiss', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ confirm: true, jobIds }),
              });
              const data = await res.json().catch(() => ({}));
              if (!res.ok) throw new Error(data?.error || `dismiss failed (${res.status})`);
              acpAsyncMetaEl.textContent = `Dismissed ${Array.isArray(data.dismissed) ? data.dismissed.length : 0} job(s)`;
              await load();
            } catch (e) {
              acpAsyncMetaEl.textContent = `Dismiss selected failed: ${e.message || e}`;
            }
          });
        }
        targetAlertEl.innerHTML = computeTargetAlert(data, targetConfig);
        const plan = computeRebalancePlan(data, targetConfig);
        lastRebalancePlan = plan;
        targetPlanEl.textContent = plan.text;

        if (data.worker) {
          workerEl.innerHTML = `<span class="ok">${data.worker.status}</span> Â· ${data.worker.dryRun ? "dry-run" : "live"}<br/><span class="muted">cycles: ${data.worker.cycleCount} Â· last: ${data.worker.lastCycleAt || "-"}</span>`;
        } else {
          workerEl.innerHTML = `<span class="warn">No worker status found in local session log</span>`;
        }

        if (data.strategy) {
          const rows = (data.strategy.currentStableCollateral || [])
            .map((r) => `${r.symbol}: ${r.amount} (APR ${(Number(r.apr || 0) * 100).toFixed(2)}%)`)
            .join("<br/>");
          strategyEl.innerHTML = `${data.strategy.recommendation}<br/><br/><span class="muted">Stable collateral APR ranking</span><br/>${rows || "none"}`;
        } else {
          strategyEl.innerHTML = `<span class="warn">No strategy data</span>`;
        }

        const payRows = Array.isArray(payments?.payments) ? payments.payments : [];
        const byPayStatus = payRows.reduce((acc, row) => {
          const k = String(row?.status || "unknown");
          acc[k] = (acc[k] || 0) + 1;
          return acc;
        }, {});
        paymentsMetaEl.textContent = `total=${payRows.length} byStatus=${JSON.stringify(byPayStatus)}`;
        paymentsRowsEl.innerHTML = "";
        for (const row of payRows.slice(0, 20)) {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${new Date(row.createdAt || Date.now()).toLocaleString()}</td><td>${row.paymentId || "-"}</td><td>${row.status || "-"}</td><td>${row.strategyId || "-"}</td><td>${row.buyer || "-"}</td><td>${row.amountUsd || "-"} ${row.currency || ""}</td>`;
          paymentsRowsEl.appendChild(tr);
        }

        tokensEl.innerHTML = "";
        for (const row of data.tokens) {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${row.symbol}</td><td>${row.amount}</td><td>$${(row.usd || 0).toFixed(2)}</td><td>${row.error ? `<span class="warn">${row.error}</span>` : "ok"}</td>`;
          tokensEl.appendChild(tr);
        }

        txsEl.innerHTML = "";
        for (const tx of data.recentTxs || []) {
          const tr = document.createElement("tr");
          const hash = tx.explorerUrl ? `<a href="${tx.explorerUrl}" target="_blank" rel="noreferrer">${tx.txHash}</a>` : tx.txHash;
          tr.innerHTML = `<td>${new Date(tx.timestamp).toLocaleString()}</td><td>${tx.tool}</td><td>${hash}</td>`;
          txsEl.appendChild(tr);
        }

        actionsEl.innerHTML = "";
        for (const row of data.actionHistory || []) {
          const tr = document.createElement("tr");
          const status = row.status === "success" ? `<span class="ok">success</span>` : `<span class="warn">error</span>`;
          const tx = row.txHash
            ? (row.explorerUrl
                ? `<a href="${row.explorerUrl}" target="_blank" rel="noreferrer">${row.txHash}</a>`
                : row.txHash)
            : "-";
          tr.innerHTML = `<td>${new Date(row.timestamp).toLocaleString()}</td><td>${row.action}</td><td>${row.step || "-"}</td><td>${status}</td><td>${tx}</td><td>${row.summary || ""}</td>`;
          actionsEl.appendChild(tr);
        }
      }

      function setCommand(text) {
        cmdOutEl.value = text;
        cmdMetaEl.textContent = "Command generated";
      }

      function currentAccount() {
        return (accountInput.value || "davirain8.near").trim();
      }

      buildWrapBtn.addEventListener("click", () => {
        const amount = (wrapAmountEl.value || "1").trim();
        setCommand(`near contract call-function as-transaction wrap.near near_deposit json-args '{}' prepaid-gas '100 Tgas' attached-deposit '${amount} NEAR' sign-as ${currentAccount()} network-config mainnet sign-with-keychain send`);
      });

      buildSupplyBtn.addEventListener("click", () => {
        const raw = (supplyRawEl.value || "1000000").trim();
        setCommand(`near_supplyBurrow network=mainnet rpcUrl=https://1rpc.io/near tokenId=usdt.tether-token.near amountRaw=${raw} asCollateral=true confirmMainnet=true`);
      });

      buildWorkerDryBtn.addEventListener("click", () => {
        setCommand(`near_yieldWorkerStart network=mainnet accountId=${currentAccount()} dryRun=true intervalSeconds=300 minAprDelta=0.5 topN=5`);
      });

      buildWorkerStopBtn.addEventListener("click", () => {
        setCommand(`near_yieldWorkerStop network=mainnet accountId=${currentAccount()}`);
      });

      copyCmdBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(cmdOutEl.value || "");
          cmdMetaEl.textContent = "Copied";
        } catch {
          cmdMetaEl.textContent = "Copy failed";
        }
      });

      testAlertsBtn.addEventListener("click", async () => {
        const ok = window.confirm("Send a test alert to configured channels?");
        if (!ok) return;
        cmdMetaEl.textContent = "Sending alert test...";
        try {
          const res = await fetch("/api/alerts/test", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              confirm: true,
              accountId: currentAccount(),
              level: "info",
              title: "Dashboard alert test",
              message: `manual test from dashboard at ${new Date().toLocaleString()}`,
            }),
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Alert test failed");
          const tg = data?.channel?.telegram ? "telegram:on" : "telegram:off";
          const wh = data?.channel?.webhook ? "webhook:on" : "webhook:off";
          cmdMetaEl.textContent = `Alert test sent (${tg}, ${wh})`;
        } catch (e) {
          cmdMetaEl.textContent = `Alert test failed: ${e.message || e}`;
        }
      });

      async function executeAction(payload) {
        const ok = window.confirm("This will execute an on-chain transaction. Continue?");
        if (!ok) return;
        cmdMetaEl.textContent = "Executing...";
        try {
          const res = await fetch("/api/action", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...payload, confirm: true, accountId: currentAccount() }),
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Action failed");
          cmdOutEl.value = data.output || "Done";
          cmdMetaEl.textContent = "Executed";
          await load();
        } catch (e) {
          cmdMetaEl.textContent = `Execution failed: ${e.message || e}`;
        }
      }

      execWrapBtn.addEventListener("click", () => {
        executeAction({
          action: "wrap_near",
          amountNear: (wrapAmountEl.value || "1").trim(),
          step: (execStepTagEl.value || "").trim() || null,
        });
      });

      execSupplyBtn.addEventListener("click", () => {
        executeAction({
          action: "supply_usdt_collateral",
          amountRaw: (supplyRawEl.value || "1000000").trim(),
          step: (execStepTagEl.value || "").trim() || null,
        });
      });

      exportCsvBtn.addEventListener("click", () => {
        if (!lastSnapshot) {
          exportMetaEl.textContent = "No snapshot to export";
          return;
        }
        const csv = toCsv(lastSnapshot);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `near-dashboard-${lastSnapshot.accountId}-${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        exportMetaEl.textContent = "Exported";
      });

      saveTargetsBtn.addEventListener("click", () => {
        targetConfig = {
          usdt: parseNum(targetUsdtEl.value),
          usdce: parseNum(targetUsdceEl.value),
          threshold: parseNum(targetThresholdEl.value),
        };
        const totalTarget = targetConfig.usdt + targetConfig.usdce;
        if (Math.abs(totalTarget - 100) > 0.01) {
          targetAlertEl.innerHTML = `<span class="warn">Target total should be 100% (current ${totalTarget.toFixed(1)}%)</span>`;
          return;
        }
        saveTargets(targetConfig);
        if (lastSnapshot) {
          targetAlertEl.innerHTML = computeTargetAlert(lastSnapshot, targetConfig);
          const plan = computeRebalancePlan(lastSnapshot, targetConfig);
          lastRebalancePlan = plan;
          targetPlanEl.textContent = plan.text;
        }
      });

      function toRaw6(uiAmount) {
        return String(Math.max(0, Math.round(parseNum(uiAmount) * 1_000_000)));
      }

      function tokenIdFromSymbol(symbol) {
        return symbol === "USDt"
          ? "usdt.tether-token.near"
          : "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near";
      }

      function buildRebalanceDraft(snapshot, targets, chain = "near") {
        const plan = computeRebalancePlan(snapshot, targets);
        if (!plan.from || !plan.to || plan.amount <= 0) {
          return { plan, text: "# No executable rebalance draft\n# Reason: " + plan.text };
        }

        const fromToken = tokenIdFromSymbol(plan.from);
        const toToken = tokenIdFromSymbol(plan.to);
        const raw = toRaw6(plan.amount);

        if (chain === "bsc") {
          return {
            plan,
            text: [
              `# Rebalance draft (${plan.from} -> ${plan.to}) [BSC skeleton]`,
              `# Estimated move amount: ${plan.amount.toFixed(6)} (${raw} raw-equivalent)`,
              `1) Withdraw source asset from lending protocol (BSC adapter)`,
              `2) Swap on Pancake/aggregator (BSC adapter) with slippage guard`,
              `3) Re-supply target asset to lending protocol (BSC adapter)`,
              `# Note: one-click transaction orchestration for BSC is not enabled yet in this dashboard backend.`,
            ].join("\n"),
          };
        }

        return {
          plan,
          text: [
            `# Rebalance draft (${plan.from} -> ${plan.to})`,
            `# Estimated move amount: ${plan.amount.toFixed(6)} (${raw} raw)`,
            `1) Withdraw from Burrow: near_withdrawBurrow network=mainnet tokenId=${fromToken} amountRaw=${raw} confirmMainnet=true`,
            `2) Swap on Ref: near_swapRef network=mainnet tokenInId=${fromToken} tokenOutId=${toToken} amountInRaw=${raw} slippageBps=50 confirmMainnet=true`,
            `3) Supply to Burrow: near_supplyBurrow network=mainnet tokenId=${toToken} amountRaw=<use swap output raw> asCollateral=true confirmMainnet=true`,
          ].join("\n"),
        };
      }

      function buildActionConsoleFromPlan(plan, chain = "near") {
        if (!plan || !plan.from || !plan.to || plan.amount <= 0) {
          return "# No executable plan to fill\n# Refresh snapshot and confirm target settings.";
        }
        const fromToken = tokenIdFromSymbol(plan.from);
        const toToken = tokenIdFromSymbol(plan.to);
        const raw = toRaw6(plan.amount);
        if (chain === "bsc") {
          return [
            `# Checklist [BSC skeleton]`,
            `# 1) chain: bsc`,
            `# 2) amount: ${plan.amount.toFixed(6)} (${raw} raw-equivalent)`,
            `# 3) route through BSC adapter`,
            ``,
            `# TODO: bsc_withdraw`,
            `# TODO: bsc_swap`,
            `# TODO: bsc_supply`,
          ].join("\n");
        }
        return [
          `# Checklist`,
          `# 1) account: ${currentAccount()}`,
          `# 2) network: mainnet`,
          `# 3) amount: ${plan.amount.toFixed(6)} (${raw} raw)`,
          `# 4) confirm before each execute`,
          ``,
          `near_withdrawBurrow network=mainnet tokenId=${fromToken} amountRaw=${raw} confirmMainnet=true`,
          `near_swapRef network=mainnet tokenInId=${fromToken} tokenOutId=${toToken} amountInRaw=${raw} slippageBps=50 confirmMainnet=true`,
          `near_supplyBurrow network=mainnet tokenId=${toToken} amountRaw=<use swap output raw> asCollateral=true confirmMainnet=true`,
        ].join("\n");
      }

      buildRebalanceDraftBtn.addEventListener("click", () => {
        if (!lastSnapshot) {
          rebalanceMetaEl.textContent = "No snapshot loaded";
          return;
        }
        const chain = (rebalanceChainEl.value || "near").trim();
        const draft = buildRebalanceDraft(lastSnapshot, targetConfig, chain);
        lastRebalancePlan = draft.plan;
        rebalanceDraftEl.value = draft.text;
        rebalanceMetaEl.textContent = `Draft built (${chain})`;
      });

      copyRebalanceDraftBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(rebalanceDraftEl.value || "");
          rebalanceMetaEl.textContent = "Draft copied";
        } catch {
          rebalanceMetaEl.textContent = "Copy failed";
        }
      });

      fillActionConsoleBtn.addEventListener("click", () => {
        const chain = (rebalanceChainEl.value || "near").trim();
        cmdOutEl.value = buildActionConsoleFromPlan(lastRebalancePlan, chain);
        cmdMetaEl.textContent = `Filled from rebalance plan (${chain})`;
      });

      execRebalanceTxnBtn.addEventListener("click", () => {
        const chain = (rebalanceChainEl.value || "near").trim();
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          rebalanceMetaEl.textContent = "No executable rebalance plan";
          return;
        }
        if (chain === "bsc") {
          executeAction({
            action: "rebalance_usdt_to_usdce_txn",
            chain,
            amountRaw: p.raw,
            slippageBps: 50,
            step: (execStepTagEl.value || "rebalance-bsc-plan").trim() || "rebalance-bsc-plan",
          });
          rebalanceMetaEl.textContent = "Submitted BSC plan-only action";
          return;
        }
        if (p.fromToken !== "usdt.tether-token.near" || p.toToken !== "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near") {
          rebalanceMetaEl.textContent = "One-click tx currently supports USDt -> USDC.e only";
          return;
        }
        executeAction({
          action: "rebalance_usdt_to_usdce_txn",
          chain,
          amountRaw: p.raw,
          slippageBps: 50,
          poolId: 3725,
          step: (execStepTagEl.value || "rebalance").trim() || "rebalance",
        });
      });

      function getPlanTokensAndRaw(plan) {
        if (!plan || !plan.from || !plan.to || plan.amount <= 0) {
          return null;
        }
        return {
          fromToken: tokenIdFromSymbol(plan.from),
          toToken: tokenIdFromSymbol(plan.to),
          raw: toRaw6(plan.amount),
        };
      }

      buildStep1Btn.addEventListener("click", () => {
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          cmdMetaEl.textContent = "No executable plan";
          return;
        }
        cmdOutEl.value = `near_withdrawBurrow network=mainnet tokenId=${p.fromToken} amountRaw=${p.raw} confirmMainnet=true`;
        cmdMetaEl.textContent = "Step1 prepared";
      });

      buildStep2Btn.addEventListener("click", () => {
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          cmdMetaEl.textContent = "No executable plan";
          return;
        }
        cmdOutEl.value = `near_swapRef network=mainnet tokenInId=${p.fromToken} tokenOutId=${p.toToken} amountInRaw=${p.raw} slippageBps=50 confirmMainnet=true`;
        cmdMetaEl.textContent = "Step2 prepared";
      });

      buildStep3Btn.addEventListener("click", () => {
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          cmdMetaEl.textContent = "No executable plan";
          return;
        }
        const outRaw = (step2OutRawEl.value || "").trim();
        if (!outRaw) {
          cmdMetaEl.textContent = "Paste Step2 output raw first";
          return;
        }
        cmdOutEl.value = `near_supplyBurrow network=mainnet tokenId=${p.toToken} amountRaw=${outRaw} asCollateral=true confirmMainnet=true`;
        cmdMetaEl.textContent = "Step3 prepared from Step2 output";
      });

      parseStep2RawBtn.addEventListener("click", () => {
        const text = (step2ResultTextEl.value || "").trim();
        if (!text) {
          cmdMetaEl.textContent = "Paste Step2 result text first";
          return;
        }
        const m = text.match(/raw\s+(\d{2,})/) || text.match(/->\s*(\d{2,})\s*raw/i) || text.match(/\b(\d{2,})\b/);
        if (!m) {
          cmdMetaEl.textContent = "Could not parse raw output";
          return;
        }
        step2OutRawEl.value = m[1];
        cmdMetaEl.textContent = `Parsed raw output: ${m[1]}`;
      });

      function renderStrategyDslHints(result) {
        const errs = Array.isArray(result?.errors) ? result.errors : [];
        const warns = Array.isArray(result?.warnings) ? result.warnings : [];
        const fieldMap = {};
        const pickKey = (line) => {
          const m = String(line || "").match(/^([a-zA-Z0-9_.-]+):/);
          return m ? m[1] : null;
        };
        for (const item of errs) {
          const k = pickKey(item);
          if (!k) continue;
          fieldMap[k] = fieldMap[k] || { errors: [], warnings: [] };
          fieldMap[k].errors.push(item);
        }
        for (const item of warns) {
          const k = pickKey(item);
          if (!k) continue;
          fieldMap[k] = fieldMap[k] || { errors: [], warnings: [] };
          fieldMap[k].warnings.push(item);
        }
        const lines = [];
        if (Object.keys(fieldMap).length > 0) {
          lines.push("Field hints:");
          for (const [k, v] of Object.entries(fieldMap)) {
            const e = v.errors.length ? `errors=${v.errors.length}` : "";
            const w = v.warnings.length ? `warnings=${v.warnings.length}` : "";
            lines.push(`- ${k} ${[e, w].filter(Boolean).join(" ")}`);
          }
        }
        return lines.join("\n");
      }

      async function runStrategyDslValidate() {
        let payload;
        try {
          payload = JSON.parse(strategyDslInputEl.value || "{}");
        } catch (e) {
          strategyDslMetaEl.textContent = `Invalid JSON: ${e.message || e}`;
          return { ok: false, localError: true };
        }
        const res = await fetch("/api/strategies/validate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        const hints = renderStrategyDslHints(data);
        strategyDslResultEl.textContent = `${JSON.stringify(data, null, 2)}${hints ? `\n\n${hints}` : ""}`;
        strategyDslMetaEl.textContent = data?.ok
          ? `Ready (${data.phase || "ready"})`
          : `Validation failed (${data.phase || "unknown"})`;
        return { ok: !!data?.ok, payload, validation: data };
      }

      async function pollAcpAsyncJob(jobId) {
        if (!jobId) return;
        try {
          const res = await fetch(`/api/acp/jobs/${encodeURIComponent(jobId)}`);
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            acpAsyncStatusEl.textContent = `job=${jobId} query failed`;
            return;
          }
          const row = data.job || {};
          acpAsyncStatusEl.textContent = `job=${row.jobId} status=${row.status} updated=${row.updatedAt || "-"}${row.error ? ` error=${row.error}` : ""}`;
          if (row.status === "queued" || row.status === "running") {
            setTimeout(() => pollAcpAsyncJob(jobId), 1500);
          } else {
            load().catch(() => {});
          }
        } catch (e) {
          acpAsyncStatusEl.textContent = `job=${jobId} polling error: ${e.message || e}`;
        }
      }

      fillStrategyDslSampleBtn?.addEventListener("click", () => {
        strategyDslInputEl.value = JSON.stringify(buildStrategyDslSample(), null, 2);
        strategyDslMetaEl.textContent = "Sample filled";
      });

      validateStrategyDslBtn?.addEventListener("click", async () => {
        strategyDslMetaEl.textContent = "Validating...";
        strategyDslResultEl.textContent = "-";
        try {
          await runStrategyDslValidate();
        } catch (e) {
          strategyDslMetaEl.textContent = `Validate request failed: ${e.message || e}`;
        }
      });

      publishStrategyDslBtn?.addEventListener("click", async () => {
        strategyDslMetaEl.textContent = "Preflight + publishing...";
        strategyDslResultEl.textContent = "-";
        try {
          const first = await runStrategyDslValidate();
          if (!first.ok || !first.payload) {
            return;
          }
          const yes = window.confirm("Validation passed. Publish this strategy now?");
          if (!yes) {
            strategyDslMetaEl.textContent = "Publish canceled";
            return;
          }
          const publishPayload = {
            ...first.payload,
            confirm: true,
          };
          const pubRes = await fetch("/api/strategies", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(publishPayload),
          });
          const pubData = await pubRes.json().catch(() => ({}));
          strategyDslResultEl.textContent = JSON.stringify(pubData, null, 2);
          if (!pubRes.ok || !pubData?.ok) {
            strategyDslMetaEl.textContent = `Publish failed: ${pubData?.error || pubRes.status}`;
            return;
          }
          strategyDslMetaEl.textContent = `Published: ${pubData?.strategy?.id || "ok"}`;
        } catch (e) {
          strategyDslMetaEl.textContent = `Publish request failed: ${e.message || e}`;
        }
      });

      submitAcpAsyncJobBtn?.addEventListener("click", async () => {
        acpAsyncMetaEl.textContent = "Submitting...";
        const payload = {
          confirm: true,
          dryRun: false,
          intentType: "rebalance",
          amountRaw: String((acpAsyncAmountRawEl?.value || "1000000").trim() || "1000000"),
        };
        const strategyId = String((acpAsyncStrategyIdEl?.value || "").trim());
        const buyer = String((acpAsyncBuyerEl?.value || "").trim());
        if (strategyId) payload.strategyId = strategyId;
        if (buyer) payload.buyer = buyer;
        try {
          const res = await fetch("/api/acp/job/submit", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            acpAsyncMetaEl.textContent = `Submit failed: ${data?.error || res.status}`;
            return;
          }
          lastAcpAsyncJobId = data.jobId;
          acpAsyncMetaEl.textContent = `Submitted: ${data.jobId}`;
          acpAsyncStatusEl.textContent = `job=${data.jobId} status=${data.status}`;
          pollAcpAsyncJob(data.jobId);
          load().catch(() => {});
        } catch (e) {
          acpAsyncMetaEl.textContent = `Submit error: ${e.message || e}`;
        }
      });

      acpDismissedPurgeBtn?.addEventListener("click", async () => {
        const days = Math.max(0, Number.parseInt(String(acpDismissedPurgeDaysEl?.value || "7"), 10) || 7);
        const ok = window.confirm(`Purge dismissed ACP jobs older than ${days} day(s)?`);
        if (!ok) return;
        acpAsyncMetaEl.textContent = `Purging dismissed jobs older than ${days} day(s)...`;
        try {
          const res = await fetch("/api/acp/jobs/dismissed/purge", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ confirm: true, olderThanDays: days }),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            throw new Error(data?.error || `purge failed (${res.status})`);
          }
          acpAsyncMetaEl.textContent = `Purged ${Number(data.removed || 0)} dismissed job(s)`;
          await load();
        } catch (e) {
          acpAsyncMetaEl.textContent = `Purge failed: ${e.message || e}`;
        }
      });

      refreshBtn.addEventListener("click", () => load().catch((e) => (metaEl.textContent = e.message)));
      bscExecutionProtocolEl?.addEventListener("change", () => {
        const selected = String(bscExecutionProtocolEl.value || "aave").toLowerCase();
        localStorage.setItem(BSC_READINESS_PROTOCOL_KEY, selected);
        load().catch(() => {});
      });
      debridgeWindowEl?.addEventListener("change", () => {
        const nextWindow = String(debridgeWindowEl.value || "24h");
        localStorage.setItem(DEBRIDGE_WINDOW_KEY, nextWindow);
        if (!lastSnapshot) return;
        debridgeReliabilityEl.textContent = computeDebridgeReliability(
          lastSnapshot,
          nextWindow,
        );
      });
      copyDebridgeReliabilityBtn?.addEventListener("click", async () => {
        const text = String(debridgeReliabilityEl?.textContent || "").trim();
        if (!text || text === "-") {
          cmdMetaEl.textContent = "No deBridge reliability summary to copy";
          return;
        }
        try {
          await navigator.clipboard.writeText(text);
          cmdMetaEl.textContent = "Copied deBridge reliability summary";
        } catch {
          cmdMetaEl.textContent = "Copy deBridge reliability summary failed";
        }
      });
      copyDebridgeIncidentBtn?.addEventListener("click", async () => {
        if (!lastSnapshot) {
          cmdMetaEl.textContent = "No snapshot available for incident summary";
          return;
        }
        const windowKey = String(debridgeWindowEl?.value || "24h");
        const report = buildDebridgeIncidentSummary(lastSnapshot, windowKey);
        try {
          await navigator.clipboard.writeText(report);
          cmdMetaEl.textContent = "Copied deBridge incident summary";
        } catch {
          cmdMetaEl.textContent = "Copy deBridge incident summary failed";
        }
      });
      fillDebridgeFixDraftBtn?.addEventListener("click", () => {
        if (!lastSnapshot) {
          cmdMetaEl.textContent = "No snapshot available for fix draft";
          return;
        }
        const windowKey = String(debridgeWindowEl?.value || "24h");
        const draft = buildDebridgeFixDraft(lastSnapshot, windowKey);
        if (cmdOutEl) cmdOutEl.value = draft;
        cmdMetaEl.textContent = "Filled deBridge fix draft into Action Console";
      });
      appendDebridgeQuickFixBtn?.addEventListener("click", () => {
        if (!lastSnapshot) {
          cmdMetaEl.textContent = "No snapshot available for quick fix";
          return;
        }
        const windowKey = String(debridgeWindowEl?.value || "24h");
        const stats = getDebridgeWindowErrorStats(lastSnapshot, windowKey);
        const code = String(stats.dominantError || lastSnapshot?.debridgeExecuteMetrics?.lastErrorCode || "");
        appendDebridgeQuickFixToConsole(code);
        cmdMetaEl.textContent = `Appended deBridge quick fix (${code || "generic"})`;
      });
      appendQuickFixTimeoutBtn?.addEventListener("click", () => {
        appendDebridgeQuickFixToConsole("debridge_execute_timeout");
        cmdMetaEl.textContent = "Appended quick fix (timeout)";
      });
      appendQuickFixRateBtn?.addEventListener("click", () => {
        appendDebridgeQuickFixToConsole("debridge_execute_rate_limited");
        cmdMetaEl.textContent = "Appended quick fix (rate-limit)";
      });
      appendQuickFixNetworkBtn?.addEventListener("click", () => {
        appendDebridgeQuickFixToConsole("debridge_execute_network_error");
        cmdMetaEl.textContent = "Appended quick fix (network)";
      });
      acpStatusFilterEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpBuyerFilterEl?.addEventListener("input", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpStrategyFilterEl?.addEventListener("input", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpOnlyFailedEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpPhaseFilterEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpDeadPhaseFilterEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpDeadTypeFilterEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpHeatmapWindowEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpDeadPresetAaveBtn?.addEventListener("click", () => {
        if (acpDeadPhaseFilterEl) acpDeadPhaseFilterEl.value = "bsc-aave-post";
        if (acpDeadTypeFilterEl) acpDeadTypeFilterEl.value = "bsc_aave_post_action_failed";
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpDeadPresetMainBtn?.addEventListener("click", () => {
        if (acpDeadPhaseFilterEl) acpDeadPhaseFilterEl.value = "main";
        if (acpDeadTypeFilterEl) acpDeadTypeFilterEl.value = "all";
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpDeadPresetAllBtn?.addEventListener("click", () => {
        if (acpDeadPhaseFilterEl) acpDeadPhaseFilterEl.value = "all";
        if (acpDeadTypeFilterEl) acpDeadTypeFilterEl.value = "all";
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpExpandErrorsEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      copyAcpFilterLinkBtn?.addEventListener("click", async () => {
        syncAcpFiltersToUrl();
        const full = window.location.href;
        try {
          await navigator.clipboard.writeText(full);
          acpAsyncMetaEl.textContent = "Filter link copied";
        } catch {
          acpAsyncMetaEl.textContent = "Copy filter link failed";
        }
      });
      resetAcpFiltersBtn?.addEventListener("click", () => {
        resetAcpFilters();
        acpAsyncMetaEl.textContent = "ACP filters reset";
        load().catch(() => {});
      });
      applyAcpFiltersFromStorage();
      applyAcpFiltersFromUrl();
      syncAcpFiltersToUrl();
      load().catch((e) => (metaEl.textContent = e.message));
      setInterval(() => load().catch(() => {}), 30000);
    </script>
  </body>
</html>
