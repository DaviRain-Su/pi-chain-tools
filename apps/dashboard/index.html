<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NEAR Agent Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #080d1f;
        --bg-2: #0d1530;
        --card: rgba(19, 29, 58, 0.72);
        --card-2: rgba(22, 35, 71, 0.9);
        --border: rgba(125, 156, 255, 0.18);
        --text: #ecf2ff;
        --muted: #9baddf;
        --accent: #7fa2ff;
        --accent-2: #89f0ff;
        --ok: #89f5ae;
        --warn: #ffd486;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: var(--text);
        background:
          radial-gradient(900px 500px at -10% -10%, #27408a44 0%, transparent 65%),
          radial-gradient(900px 500px at 110% -20%, #32bfd433 0%, transparent 60%),
          linear-gradient(160deg, var(--bg) 0%, var(--bg-2) 100%);
        min-height: 100vh;
      }

      .wrap {
        max-width: 1120px;
        margin: 0 auto;
        padding: 28px 20px 40px;
      }

      h1 {
        margin: 0 0 8px;
        font-size: 30px;
        letter-spacing: 0.2px;
      }

      h3 {
        margin: 0 0 10px;
        font-size: 17px;
        letter-spacing: 0.2px;
      }

      .muted { color: var(--muted); }

      .grid {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }

      .card {
        background: linear-gradient(180deg, var(--card) 0%, var(--card-2) 100%);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 14px;
        backdrop-filter: blur(10px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.22);
      }

      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      input, button, textarea {
        border-radius: 10px;
        border: 1px solid #34456f;
        background: #0d1731;
        color: var(--text);
        padding: 8px 10px;
        transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.08s ease;
      }

      input:focus, textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(127, 162, 255, 0.18);
      }

      button {
        cursor: pointer;
        background: linear-gradient(180deg, #1a2a55 0%, #142245 100%);
        border-color: #3d5896;
        font-weight: 600;
      }

      button:hover {
        border-color: #6f93f5;
        box-shadow: 0 6px 18px rgba(111, 147, 245, 0.25);
      }

      button:active { transform: translateY(1px); }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        overflow: hidden;
        border-radius: 10px;
      }

      th, td {
        padding: 10px 8px;
        border-bottom: 1px solid #27385f;
        text-align: left;
        font-size: 13px;
      }

      th {
        color: #c9d7ff;
        font-weight: 600;
        background: rgba(14, 23, 49, 0.65);
        position: sticky;
        top: 0;
      }

      tr:hover td { background: rgba(146, 178, 255, 0.06); }

      .ok {
        color: var(--ok);
        font-weight: 600;
      }

      .warn {
        color: var(--warn);
        font-weight: 600;
      }

      a {
        color: var(--accent-2);
        text-decoration: none;
      }

      a:hover { text-decoration: underline; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>NEAR Agent Dashboard</h1>
      <p class="muted">Portfolio + Burrow + worker/runtime status in one page.</p>
      <div class="row" style="margin-bottom:16px">
        <input id="accountId" size="36" placeholder="account.near" />
        <button id="refresh">Refresh</button>
        <span id="meta" class="muted"></span>
      </div>

      <div class="grid">
        <div class="card"><h3>NEAR Wallet</h3><div id="near">-</div></div>
        <div class="card"><h3>Burrow Registration</h3><div id="burrowReg">-</div></div>
        <div class="card"><h3>Yield Worker</h3><div id="worker">-</div></div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Yield Health</h3>
        <div id="yieldHealth" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Execution Quality</h3>
        <div id="execQuality" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>ACP Ops</h3>
        <div id="acpOps" class="muted">-</div>
        <div class="row" style="margin-top:8px">
          <input id="acpAsyncStrategyId" placeholder="strategyId (optional)" size="20" />
          <input id="acpAsyncBuyer" placeholder="buyer (for entitlement)" size="20" />
          <input id="acpAsyncAmountRaw" placeholder="amountRaw (default 1000000)" size="20" />
          <button id="submitAcpAsyncJob">Submit ACP Async Job</button>
          <span id="acpAsyncMeta" class="muted"></span>
        </div>
        <div id="acpAsyncStatus" class="muted" style="margin-top:6px">-</div>
        <details style="margin-top:10px">
          <summary>Recent ACP Jobs</summary>
          <div class="row" style="margin:8px 0">
            <label class="muted" for="acpStatusFilter">Status</label>
            <select id="acpStatusFilter">
              <option value="all">all</option>
              <option value="dry-run">dry-run</option>
              <option value="planned">planned</option>
              <option value="executed">executed</option>
              <option value="blocked">blocked</option>
              <option value="error">error</option>
            </select>
            <input id="acpBuyerFilter" placeholder="buyer filter" size="16" />
            <input id="acpStrategyFilter" placeholder="strategyId filter" size="16" />
            <label class="muted" style="display:flex;align-items:center;gap:4px"><input id="acpOnlyFailed" type="checkbox" />only failed</label>
            <label class="muted" style="display:flex;align-items:center;gap:4px"><input id="acpExpandErrors" type="checkbox" checked />auto-expand errors</label>
            <button id="copyAcpFilterLink">Copy filter link</button>
            <button id="resetAcpFilters">Reset filters</button>
          </div>
          <table style="margin-top:8px">
            <thead><tr><th>Time</th><th>RunId</th><th>Status</th><th>Chain</th><th>Intent</th><th>Strategy</th><th>Buyer</th><th>Remaining</th><th>AmountRaw</th><th>Tx</th></tr></thead>
            <tbody id="acpJobs"></tbody>
          </table>
        </details>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Target Allocation Alert</h3>
        <div class="row" style="margin-bottom:8px">
          <input id="targetUsdt" type="number" min="0" max="100" step="0.1" placeholder="USDt target %" size="14" />
          <input id="targetUsdce" type="number" min="0" max="100" step="0.1" placeholder="USDC.e target %" size="14" />
          <input id="targetThreshold" type="number" min="0" max="100" step="0.1" placeholder="Alert threshold %" size="16" />
          <button id="saveTargets">Save</button>
        </div>
        <div id="targetAlert" class="muted">-</div>
        <div id="targetPlan" class="muted" style="margin-top:8px">-</div>
        <div style="margin-top:10px">
          <textarea id="rebalanceDraft" rows="6" style="width:100%;border-radius:8px;border:1px solid #2d3656;background:#0e1529;color:#e8eefc;padding:8px" placeholder="Rebalance execution draft will appear here"></textarea>
        </div>
        <div class="row" style="margin-top:8px">
          <select id="rebalanceChain">
            <option value="near">near</option>
            <option value="bsc">bsc</option>
          </select>
          <button id="buildRebalanceDraft">Build execution draft</button>
          <button id="copyRebalanceDraft">Copy draft</button>
          <button id="fillActionConsole">Fill Action Console</button>
          <button id="execRebalanceTxn">Execute Rebalance Txn (auto rollback)</button>
          <span id="rebalanceMeta" class="muted"></span>
        </div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Strategy View</h3>
        <div id="strategy" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Strategy DSL Validate (Preflight)</h3>
        <p class="muted">Validate strategy DSL without persisting (schema + semantic policy checks).</p>
        <textarea id="strategyDslInput" rows="8" style="width:100%;border-radius:8px;border:1px solid #2d3656;background:#0e1529;color:#e8eefc;padding:8px"></textarea>
        <div class="row" style="margin-top:8px">
          <button id="fillStrategyDslSample">Fill sample</button>
          <button id="validateStrategyDsl">Validate DSL</button>
          <button id="publishStrategyDsl">Publish Strategy</button>
          <span id="strategyDslMeta" class="muted"></span>
        </div>
        <pre id="strategyDslResult" class="muted" style="white-space:pre-wrap;margin-top:8px">-</pre>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Burrow Positions</h3>
        <div id="burrowPos" class="muted">-</div>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Tracked Token Balances</h3>
        <table>
          <thead><tr><th>Token</th><th>Balance</th><th>~USD</th><th>Status</th></tr></thead>
          <tbody id="tokens"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Recent Executions (local session)</h3>
        <div class="row" style="margin-bottom:8px">
          <button id="exportCsv">Export snapshot CSV</button>
          <span id="exportMeta" class="muted"></span>
        </div>
        <table>
          <thead><tr><th>Time</th><th>Tool</th><th>Tx Hash</th></tr></thead>
          <tbody id="txs"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Action History</h3>
        <table>
          <thead><tr><th>Time</th><th>Action</th><th>Step</th><th>Status</th><th>Tx</th><th>Summary</th></tr></thead>
          <tbody id="actions"></tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Action Console</h3>
        <p class="muted">Supports command build + confirmed direct execution for selected actions.</p>
        <div class="row">
          <input id="wrapAmount" placeholder="Wrap amount NEAR (e.g. 1)" size="24" />
          <button id="buildWrap">Build wrap command</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="supplyRaw" placeholder="Supply raw (USDt, e.g. 1000000)" size="24" />
          <button id="buildSupply">Build supply command</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="execWrap">Execute wrap (confirmed)</button>
          <button id="execSupply">Execute supply USDt (confirmed)</button>
          <input id="execStepTag" placeholder="step tag (e.g. step1)" size="16" />
        </div>
        <div class="row" style="margin-top:8px">
          <button id="buildWorkerDry">Build worker dry-run start</button>
          <button id="buildWorkerStop">Build worker stop</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="buildStep1">Build Step1 (withdraw)</button>
          <button id="buildStep2">Build Step2 (swap)</button>
          <input id="step2OutRaw" placeholder="Step2 output raw" size="18" />
          <button id="buildStep3">Build Step3 (supply)</button>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="step2ResultText" placeholder="Paste Step2 result text here" size="42" />
          <button id="parseStep2Raw">Parse output raw</button>
        </div>
        <div style="margin-top:10px">
          <textarea id="cmdOut" rows="6" style="width:100%;border-radius:8px;border:1px solid #2d3656;background:#0e1529;color:#e8eefc;padding:8px"></textarea>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="copyCmd">Copy command</button>
          <button id="testAlerts">Test alerts</button>
          <span id="cmdMeta" class="muted"></span>
        </div>
      </div>
    </div>

    <script>
      const accountInput = document.getElementById("accountId");
      const refreshBtn = document.getElementById("refresh");
      const nearEl = document.getElementById("near");
      const burrowRegEl = document.getElementById("burrowReg");
      const workerEl = document.getElementById("worker");
      const yieldHealthEl = document.getElementById("yieldHealth");
      const execQualityEl = document.getElementById("execQuality");
      const acpOpsEl = document.getElementById("acpOps");
      const acpJobsEl = document.getElementById("acpJobs");
      const acpStatusFilterEl = document.getElementById("acpStatusFilter");
      const acpBuyerFilterEl = document.getElementById("acpBuyerFilter");
      const acpStrategyFilterEl = document.getElementById("acpStrategyFilter");
      const acpOnlyFailedEl = document.getElementById("acpOnlyFailed");
      const acpExpandErrorsEl = document.getElementById("acpExpandErrors");
      const copyAcpFilterLinkBtn = document.getElementById("copyAcpFilterLink");
      const resetAcpFiltersBtn = document.getElementById("resetAcpFilters");
      const acpAsyncStrategyIdEl = document.getElementById("acpAsyncStrategyId");
      const acpAsyncBuyerEl = document.getElementById("acpAsyncBuyer");
      const acpAsyncAmountRawEl = document.getElementById("acpAsyncAmountRaw");
      const submitAcpAsyncJobBtn = document.getElementById("submitAcpAsyncJob");
      const acpAsyncMetaEl = document.getElementById("acpAsyncMeta");
      const acpAsyncStatusEl = document.getElementById("acpAsyncStatus");
      const strategyEl = document.getElementById("strategy");
      const strategyDslInputEl = document.getElementById("strategyDslInput");
      const fillStrategyDslSampleBtn = document.getElementById("fillStrategyDslSample");
      const validateStrategyDslBtn = document.getElementById("validateStrategyDsl");
      const publishStrategyDslBtn = document.getElementById("publishStrategyDsl");
      const strategyDslMetaEl = document.getElementById("strategyDslMeta");
      const strategyDslResultEl = document.getElementById("strategyDslResult");
      const targetUsdtEl = document.getElementById("targetUsdt");
      const targetUsdceEl = document.getElementById("targetUsdce");
      const targetThresholdEl = document.getElementById("targetThreshold");
      const saveTargetsBtn = document.getElementById("saveTargets");
      const targetAlertEl = document.getElementById("targetAlert");
      const targetPlanEl = document.getElementById("targetPlan");
      const rebalanceDraftEl = document.getElementById("rebalanceDraft");
      const rebalanceChainEl = document.getElementById("rebalanceChain");
      const buildRebalanceDraftBtn = document.getElementById("buildRebalanceDraft");
      const copyRebalanceDraftBtn = document.getElementById("copyRebalanceDraft");
      const fillActionConsoleBtn = document.getElementById("fillActionConsole");
      const execRebalanceTxnBtn = document.getElementById("execRebalanceTxn");
      const rebalanceMetaEl = document.getElementById("rebalanceMeta");
      const burrowPosEl = document.getElementById("burrowPos");
      const metaEl = document.getElementById("meta");
      const tokensEl = document.getElementById("tokens");
      const txsEl = document.getElementById("txs");
      const exportCsvBtn = document.getElementById("exportCsv");
      const exportMetaEl = document.getElementById("exportMeta");
      const actionsEl = document.getElementById("actions");
      const wrapAmountEl = document.getElementById("wrapAmount");
      const supplyRawEl = document.getElementById("supplyRaw");
      const buildWrapBtn = document.getElementById("buildWrap");
      const buildSupplyBtn = document.getElementById("buildSupply");
      const buildWorkerDryBtn = document.getElementById("buildWorkerDry");
      const buildWorkerStopBtn = document.getElementById("buildWorkerStop");
      const buildStep1Btn = document.getElementById("buildStep1");
      const buildStep2Btn = document.getElementById("buildStep2");
      const buildStep3Btn = document.getElementById("buildStep3");
      const step2OutRawEl = document.getElementById("step2OutRaw");
      const step2ResultTextEl = document.getElementById("step2ResultText");
      const parseStep2RawBtn = document.getElementById("parseStep2Raw");
      const execWrapBtn = document.getElementById("execWrap");
      const execSupplyBtn = document.getElementById("execSupply");
      const execStepTagEl = document.getElementById("execStepTag");
      const cmdOutEl = document.getElementById("cmdOut");
      const copyCmdBtn = document.getElementById("copyCmd");
      const testAlertsBtn = document.getElementById("testAlerts");
      const cmdMetaEl = document.getElementById("cmdMeta");

      function rowsToText(rows) {
        if (!rows || rows.length === 0) return "none";
        return rows.map((r) => `${r.symbol}: ${r.amount}`).join(" · ");
      }

      function applyAcpFiltersFromStorage() {
        try {
          const s = JSON.parse(localStorage.getItem(ACP_FILTERS_KEY) || "{}");
          if (acpStatusFilterEl && s.acpStatus) acpStatusFilterEl.value = s.acpStatus;
          if (acpBuyerFilterEl && typeof s.acpBuyer === "string") acpBuyerFilterEl.value = s.acpBuyer;
          if (acpStrategyFilterEl && typeof s.acpStrategy === "string") acpStrategyFilterEl.value = s.acpStrategy;
          if (acpOnlyFailedEl) acpOnlyFailedEl.checked = s.acpOnlyFailed === true;
          if (acpExpandErrorsEl) acpExpandErrorsEl.checked = s.acpExpandErrors !== false;
        } catch {}
      }

      function applyAcpFiltersFromUrl() {
        if (!window.location.search) return;
        const p = new URLSearchParams(window.location.search);
        if (acpStatusFilterEl && p.get("acpStatus")) acpStatusFilterEl.value = p.get("acpStatus");
        if (acpBuyerFilterEl && p.get("acpBuyer")) acpBuyerFilterEl.value = p.get("acpBuyer");
        if (acpStrategyFilterEl && p.get("acpStrategy")) acpStrategyFilterEl.value = p.get("acpStrategy");
        if (acpOnlyFailedEl && p.get("acpOnlyFailed")) acpOnlyFailedEl.checked = p.get("acpOnlyFailed") === "1";
      }

      function saveAcpFiltersToStorage() {
        const payload = {
          acpStatus: acpStatusFilterEl?.value || "all",
          acpBuyer: acpBuyerFilterEl?.value || "",
          acpStrategy: acpStrategyFilterEl?.value || "",
          acpOnlyFailed: !!acpOnlyFailedEl?.checked,
          acpExpandErrors: !!acpExpandErrorsEl?.checked,
        };
        localStorage.setItem(ACP_FILTERS_KEY, JSON.stringify(payload));
      }

      function syncAcpFiltersToUrl() {
        saveAcpFiltersToStorage();
        const qp = new URLSearchParams(window.location.search);
        const setOrDelete = (key, val) => {
          if (val === undefined || val === null || String(val) === "") qp.delete(key);
          else qp.set(key, String(val));
        };
        setOrDelete("acpStatus", acpStatusFilterEl?.value || "all");
        setOrDelete("acpBuyer", acpBuyerFilterEl?.value || "");
        setOrDelete("acpStrategy", acpStrategyFilterEl?.value || "");
        setOrDelete("acpOnlyFailed", acpOnlyFailedEl?.checked ? "1" : "");
        const next = `${window.location.pathname}?${qp.toString()}`.replace(/\?$/, "");
        window.history.replaceState(null, "", next);
      }

      function resetAcpFilters() {
        if (acpStatusFilterEl) acpStatusFilterEl.value = "all";
        if (acpBuyerFilterEl) acpBuyerFilterEl.value = "";
        if (acpStrategyFilterEl) acpStrategyFilterEl.value = "";
        if (acpOnlyFailedEl) acpOnlyFailedEl.checked = false;
        if (acpExpandErrorsEl) acpExpandErrorsEl.checked = true;
        syncAcpFiltersToUrl();
      }

      function parseNum(value) {
        const n = Number.parseFloat(String(value || "0"));
        return Number.isFinite(n) ? n : 0;
      }

      const TARGET_KEY = "near-dashboard-targets-v1";
      const ACP_FILTERS_KEY = "near-dashboard-acp-filters-v1";

      function loadTargets() {
        try {
          const parsed = JSON.parse(localStorage.getItem(TARGET_KEY) || "{}");
          return {
            usdt: parseNum(parsed.usdt) || 70,
            usdce: parseNum(parsed.usdce) || 30,
            threshold: parseNum(parsed.threshold) || 10,
          };
        } catch {
          return { usdt: 70, usdce: 30, threshold: 10 };
        }
      }

      function saveTargets(targets) {
        localStorage.setItem(TARGET_KEY, JSON.stringify(targets));
      }

      function normalizeStableSymbol(symbol) {
        const s = String(symbol || "").toUpperCase();
        if (s === "USDT" || s === "USDT.E" || s === "USDT") return "USDT";
        if (s === "USDC.E") return "USDC.E";
        if (s === "USDCE") return "USDC.E";
        return s;
      }

      function getStableMix(snapshot) {
        const coll = snapshot?.burrow?.collateral || [];
        const stable = coll.map((r) => ({
          symbol: normalizeStableSymbol(r.symbol),
          amount: parseNum(r.amount),
        }));
        const total = stable.reduce((sum, r) => sum + r.amount, 0);
        const usdt = stable.filter((r) => r.symbol === "USDT").reduce((s, r) => s + r.amount, 0);
        const usdce = stable.filter((r) => r.symbol === "USDC.E").reduce((s, r) => s + r.amount, 0);
        return { total, usdt, usdce };
      }

      function computeTargetAlert(snapshot, targets) {
        const mix = getStableMix(snapshot);
        if (mix.total <= 0) return "No collateral yet, target tracking pending.";

        const usdtPct = (mix.usdt / mix.total) * 100;
        const usdcePct = (mix.usdce / mix.total) * 100;

        const usdtDelta = usdtPct - targets.usdt;
        const usdceDelta = usdcePct - targets.usdce;
        const alert =
          Math.abs(usdtDelta) > targets.threshold ||
          Math.abs(usdceDelta) > targets.threshold;

        const status = alert
          ? `<span class="warn">ALERT</span>`
          : `<span class="ok">ON TARGET</span>`;

        return `${status} · USDt ${usdtPct.toFixed(1)}% (target ${targets.usdt.toFixed(
          1,
        )}%, Δ ${usdtDelta >= 0 ? "+" : ""}${usdtDelta.toFixed(
          1,
        )}%) · USDC.e ${usdcePct.toFixed(1)}% (target ${targets.usdce.toFixed(
          1,
        )}%, Δ ${usdceDelta >= 0 ? "+" : ""}${usdceDelta.toFixed(1)}%)`;
      }

      function computeRebalancePlan(snapshot, targets) {
        const mix = getStableMix(snapshot);
        if (mix.total <= 0) {
          return { text: "No rebalance plan: stable collateral is empty.", amount: 0, from: null, to: null };
        }

        const targetUsdtAmount = (targets.usdt / 100) * mix.total;
        const targetUsdceAmount = (targets.usdce / 100) * mix.total;
        const usdtGap = targetUsdtAmount - mix.usdt;
        const usdceGap = targetUsdceAmount - mix.usdce;

        if (Math.abs(usdtGap) < 0.000001 && Math.abs(usdceGap) < 0.000001) {
          return { text: "Rebalance plan: already at target.", amount: 0, from: null, to: null };
        }

        if (usdtGap > 0 && usdceGap < 0) {
          const amount = Math.min(usdtGap, -usdceGap);
          return {
            text: `Suggestion: move ${amount.toFixed(6)} from USDC.e -> USDt.`,
            amount,
            from: "USDC.e",
            to: "USDt",
          };
        }

        if (usdceGap > 0 && usdtGap < 0) {
          const amount = Math.min(usdceGap, -usdtGap);
          return {
            text: `Suggestion: move ${amount.toFixed(6)} from USDt -> USDC.e.`,
            amount,
            from: "USDt",
            to: "USDC.e",
          };
        }

        return {
          text: `Suggestion: adjust composition manually (USDt gap ${usdtGap.toFixed(6)}, USDC.e gap ${usdceGap.toFixed(6)}).`,
          amount: 0,
          from: null,
          to: null,
        };
      }

      function computeYieldHealth(snapshot) {
        const coll = snapshot?.burrow?.collateral || [];
        if (coll.length === 0) {
          return "No stable collateral yet.";
        }
        const rows = coll.map((r) => ({
          symbol: r.symbol,
          amount: parseNum(r.amount),
          apr: parseNum(r.apr) * 100,
        }));
        const total = rows.reduce((sum, r) => sum + r.amount, 0);
        const weightedApr = total > 0 ? rows.reduce((sum, r) => sum + r.amount * r.apr, 0) / total : 0;
        const composition = rows
          .sort((a, b) => b.amount - a.amount)
          .map((r) => `${r.symbol} ${(total > 0 ? (r.amount / total) * 100 : 0).toFixed(1)}% @ ${r.apr.toFixed(2)}%`)
          .join(" · ");
        return `Estimated weighted APR: ${weightedApr.toFixed(2)}% · Collateral total: ${total.toFixed(6)} · ${composition}`;
      }

      function computeExecutionQuality(snapshot) {
        const m = snapshot?.rebalanceMetrics;
        if (!m) return "No execution metrics yet.";
        const total = Number(m.totalRuns || 0);
        const success = Number(m.successRuns || 0);
        const failed = Number(m.failedRuns || 0);
        const rollback = Number(m.rollbackRuns || 0);
        const reconcileWarn = Number(m.reconcileWarnings || 0);
        const successRate = total > 0 ? (success / total) * 100 : 0;
        const latest = (m.recent || [])[0] || null;
        const latestText = latest
          ? `Latest: ${latest.status} · runId=${latest.runId || "-"}`
          : "Latest: -";
        const latestPnl = (m.pnlSeries || [])[0] || null;
        const pnlText = latestPnl
          ? `Δstable: ${(Number(latestPnl.deltaStable || 0)).toFixed(6)} (before ${Number(latestPnl.beforeTotalStable || 0).toFixed(6)} -> after ${Number(latestPnl.afterTotalStable || 0).toFixed(6)})`
          : "Δstable: n/a";
        const r = snapshot?.rpcMetrics || {};
        const retryRate = Number(r.retryRate || 0) * 100;
        const rpcText = `RPC attempts=${Number(r.totalAttempts || 0)} retries=${Number(r.totalRetries || 0)} retryRate=${retryRate.toFixed(1)}% 429=${Number(r.http429 || 0)} 5xx=${Number(r.http5xx || 0)}`;
        const rpcDetail = `lastOK=${r.lastSuccessEndpoint || "-"} lastErr=${r.lastError || "-"}`;
        const top = (r.ranking || [])[0] || null;
        const topText = top
          ? `best=${top.endpoint} score=${Number(top.score || 0).toFixed(2)}`
          : "best=-";
        return `Runs: ${total} · Success: ${success} · Failed: ${failed} · Rollback: ${rollback} · Reconcile warns: ${reconcileWarn} · Success rate: ${successRate.toFixed(1)}% · ${latestText} · ${pnlText} · ${rpcText} · ${rpcDetail} · ${topText}`;
      }

      function toCsv(snapshot) {
        const lines = [
          ["section", "key", "value"],
          ["meta", "accountId", snapshot.accountId],
          ["meta", "updatedAt", snapshot.updatedAt],
          ["near", "available", snapshot.near.available],
          ["near", "locked", snapshot.near.locked],
        ];
        for (const row of snapshot.tokens || []) {
          lines.push(["token", row.symbol, row.amount]);
        }
        for (const row of snapshot.burrow?.collateral || []) {
          lines.push(["burrow_collateral", row.symbol, row.amount]);
        }
        return lines.map((cols) => cols.map((c) => `"${String(c).replaceAll('"', '""')}"`).join(",")).join("\n");
      }

      let lastSnapshot = null;
      let lastRebalancePlan = null;
      let lastAcpAsyncJobId = "";
      let targetConfig = loadTargets();
      targetUsdtEl.value = targetConfig.usdt;
      targetUsdceEl.value = targetConfig.usdce;
      targetThresholdEl.value = targetConfig.threshold;
      if (strategyDslInputEl && !strategyDslInputEl.value) {
        strategyDslInputEl.value = JSON.stringify(buildStrategyDslSample(), null, 2);
      }

      function buildStrategyDslSample() {
        return {
          dsl: {
            id: "stable-rebalance-near-v1",
            name: "Stable Rebalance NEAR",
            creator: currentAccount(),
            version: "1.0.0",
            targetChain: "near",
            intentType: "rebalance.usdt_to_usdce",
            pricing: {
              priceUsd: 9.9,
              currency: "USDC",
            },
            risk: {
              maxAmountUsd: 100,
              maxSlippageBps: 80,
              dailyRunLimit: 3,
            },
            execution: {
              mode: "plan-only",
            },
            inputs: {
              tokenIn: "USDt",
              tokenOut: "USDC.e",
            },
          },
        };
      }

      async function load() {
        const accountId = accountInput.value.trim();
        const query = accountId ? `?accountId=${encodeURIComponent(accountId)}` : "";
        const [snapRes, acpStatusRes, acpSummaryRes, acpJobsRes] = await Promise.all([
          fetch(`/api/snapshot${query}`),
          fetch("/api/acp/status"),
          fetch("/api/acp/jobs/summary"),
          fetch("/api/acp/jobs"),
        ]);
        const data = await snapRes.json();
        const acpStatus = await acpStatusRes.json().catch(() => ({ ok: false }));
        const acpSummary = await acpSummaryRes.json().catch(() => ({ ok: false }));
        const acpJobs = await acpJobsRes.json().catch(() => ({ ok: false, jobs: [] }));
        if (!snapRes.ok) {
          metaEl.textContent = `Error: ${data.error || "Unknown"}`;
          return;
        }

        lastSnapshot = data;
        accountInput.value = data.accountId;
        metaEl.textContent = `Updated: ${new Date(data.updatedAt).toLocaleString()} · RPC: ${data.rpcUrl}`;
        nearEl.innerHTML = `${data.near.available} NEAR <span class="muted">(~$${data.near.usd.toFixed(2)})</span><br/><span class="muted">locked: ${data.near.locked}</span>`;

        burrowRegEl.innerHTML = data.burrow.registered ? `<span class="ok">Registered</span>` : `<span class="warn">Not registered</span>`;
        burrowPosEl.innerHTML = `Collateral: ${rowsToText(data.burrow.collateral)}<br/>Supplied: ${rowsToText(data.burrow.supplied)}<br/>Borrowed: ${rowsToText(data.burrow.borrowed)}`;
        yieldHealthEl.textContent = computeYieldHealth(data);
        execQualityEl.textContent = computeExecutionQuality(data);
        const acpOk = acpStatus?.ok ? "ok" : "warn";
        const who = acpStatus?.whoami?.name || acpStatus?.whoami?.agentName || "-";
        const totalJobs = Number(acpSummary?.summary?.total || 0);
        const byStatus = acpSummary?.summary?.byStatus || {};
        const daily = acpSummary?.summary?.dailyState || {};
        const dailyLimit = Number(acpSummary?.summary?.policyDailyLimit || 0);
        const queueRows = Array.isArray(acpJobs?.queue) ? acpJobs.queue : [];
        const queueStats = queueRows.reduce((acc, row) => {
          const k = String(row?.status || "unknown");
          acc[k] = (acc[k] || 0) + 1;
          return acc;
        }, {});
        acpOpsEl.innerHTML = `<span class="${acpOk}">${acpStatus?.ok ? "connected" : "not connected"}</span> · agent=${who}<br/><span class="muted">jobs=${totalJobs} byStatus=${JSON.stringify(byStatus)} daily=${Number(daily.dailyCount || 0)}/${dailyLimit || "-"} queue=${JSON.stringify(queueStats)}</span>`;
        acpJobsEl.innerHTML = "";
        const statusFilter = (acpStatusFilterEl?.value || "all").trim();
        const buyerFilter = String(acpBuyerFilterEl?.value || "").trim().toLowerCase();
        const strategyFilter = String(acpStrategyFilterEl?.value || "").trim().toLowerCase();
        const onlyFailed = !!acpOnlyFailedEl?.checked;
        const filteredJobs = (acpJobs?.jobs || [])
          .filter((row) => statusFilter === "all" || String(row?.status || "") === statusFilter)
          .filter((row) => !buyerFilter || String(row?.buyer || "").toLowerCase().includes(buyerFilter))
          .filter((row) => !strategyFilter || String(row?.strategyId || "").toLowerCase().includes(strategyFilter))
          .filter((row) => !onlyFailed || ["error", "blocked"].includes(String(row?.status || "").toLowerCase()))
          .slice(0, 20);
        for (const row of filteredJobs) {
          const tr = document.createElement("tr");
          let tx = "-";
          if (row.txHash) {
            if (String(row.targetChain || "").toLowerCase() === "near") {
              const href = `https://explorer.near.org/transactions/${row.txHash}`;
              tx = `<a href="${href}" target="_blank" rel="noreferrer">${row.txHash}</a>`;
            } else {
              tx = row.txHash;
            }
          }
          tr.innerHTML = `<td>${new Date(row.timestamp).toLocaleString()}</td><td>${row.runId || "-"}</td><td>${row.status || "-"}</td><td>${row.targetChain || "-"}</td><td>${row.intentType || "-"}</td><td>${row.strategyId || "-"}</td><td>${row.buyer || "-"}</td><td>${row.remainingUses ?? "-"}</td><td>${row.amountRaw || "-"}</td><td>${tx}</td>`;
          tr.style.cursor = "pointer";
          tr.title = "Click to expand job details";

          const detailTr = document.createElement("tr");
          detailTr.style.display = "none";
          const detailTd = document.createElement("td");
          detailTd.colSpan = 10;
          const detailJson = JSON.stringify(row, null, 2);
          const detailTxHash = String(row.txHash || "").trim();
          const detailChain = String(row.targetChain || "").toLowerCase();
          const detailExplorer = detailTxHash
            ? detailChain === "near"
              ? `https://explorer.near.org/transactions/${detailTxHash}`
              : detailChain === "bsc"
                ? `https://bscscan.com/tx/${detailTxHash}`
                : ""
            : "";
          const detailReceipt = row.receipt ? JSON.stringify(row.receipt, null, 2) : "-";
          const detailResult = row.result ? JSON.stringify(row.result, null, 2) : "-";
          const detailError = row.error ? JSON.stringify(row.error, null, 2) : "-";
          const hasError = String(row.status || "").toLowerCase() === "error" || !!row.error;
          const expandErrorBlocks = !!acpExpandErrorsEl?.checked && hasError;
          detailTd.innerHTML = `<div class="row" style="margin-bottom:6px"><button data-copy-json="1">Copy JSON</button><button data-copy-run="1">Copy runId/jobId</button><button data-copy-tx="1">Copy txHash</button><button data-open-explorer="1">Open explorer</button><span class="muted" data-copy-meta="1"></span></div><details style="margin:4px 0" ${expandErrorBlocks ? "open" : ""}><summary>receipt</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailReceipt}</pre></details><details style="margin:4px 0" ${expandErrorBlocks ? "open" : ""}><summary>result</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailResult}</pre></details><details style="margin:4px 0" ${expandErrorBlocks ? "open" : ""}><summary>${hasError ? "⚠ error" : "error"}</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailError}</pre></details><details style="margin:4px 0"><summary>raw</summary><pre class="muted" style="white-space:pre-wrap;margin:4px 0">${detailJson}</pre></details>`;
          detailTr.appendChild(detailTd);

          const copyJsonBtn = detailTd.querySelector('[data-copy-json="1"]');
          const copyRunBtn = detailTd.querySelector('[data-copy-run="1"]');
          const copyTxBtn = detailTd.querySelector('[data-copy-tx="1"]');
          const openExplorerBtn = detailTd.querySelector('[data-open-explorer="1"]');
          const copyMetaEl = detailTd.querySelector('[data-copy-meta="1"]');
          copyJsonBtn?.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            try {
              await navigator.clipboard.writeText(detailJson);
              if (copyMetaEl) copyMetaEl.textContent = "JSON copied";
            } catch {
              if (copyMetaEl) copyMetaEl.textContent = "Copy JSON failed";
            }
          });
          copyRunBtn?.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            const token = String(row.runId || row.jobId || row.id || "");
            if (!token) {
              if (copyMetaEl) copyMetaEl.textContent = "No runId/jobId";
              return;
            }
            try {
              await navigator.clipboard.writeText(token);
              if (copyMetaEl) copyMetaEl.textContent = `Copied: ${token}`;
            } catch {
              if (copyMetaEl) copyMetaEl.textContent = "Copy runId/jobId failed";
            }
          });
          copyTxBtn?.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            if (!detailTxHash) {
              if (copyMetaEl) copyMetaEl.textContent = "No txHash";
              return;
            }
            try {
              await navigator.clipboard.writeText(detailTxHash);
              if (copyMetaEl) copyMetaEl.textContent = `txHash copied: ${detailTxHash}`;
            } catch {
              if (copyMetaEl) copyMetaEl.textContent = "Copy txHash failed";
            }
          });
          openExplorerBtn?.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (!detailExplorer) {
              if (copyMetaEl) copyMetaEl.textContent = "No explorer URL for this chain/tx";
              return;
            }
            window.open(detailExplorer, "_blank", "noopener,noreferrer");
            if (copyMetaEl) copyMetaEl.textContent = "Explorer opened";
          });

          tr.addEventListener("click", () => {
            detailTr.style.display = detailTr.style.display === "none" ? "table-row" : "none";
          });

          acpJobsEl.appendChild(tr);
          acpJobsEl.appendChild(detailTr);
        }
        if (lastAcpAsyncJobId) {
          const inQueue = (acpJobs?.queue || []).find((x) => String(x?.jobId || "") === String(lastAcpAsyncJobId));
          if (inQueue) {
            acpAsyncStatusEl.textContent = `job=${inQueue.jobId} status=${inQueue.status} updated=${inQueue.updatedAt || "-"}${inQueue.error ? ` error=${inQueue.error}` : ""}`;
          }
        }
        targetAlertEl.innerHTML = computeTargetAlert(data, targetConfig);
        const plan = computeRebalancePlan(data, targetConfig);
        lastRebalancePlan = plan;
        targetPlanEl.textContent = plan.text;

        if (data.worker) {
          workerEl.innerHTML = `<span class="ok">${data.worker.status}</span> · ${data.worker.dryRun ? "dry-run" : "live"}<br/><span class="muted">cycles: ${data.worker.cycleCount} · last: ${data.worker.lastCycleAt || "-"}</span>`;
        } else {
          workerEl.innerHTML = `<span class="warn">No worker status found in local session log</span>`;
        }

        if (data.strategy) {
          const rows = (data.strategy.currentStableCollateral || [])
            .map((r) => `${r.symbol}: ${r.amount} (APR ${(Number(r.apr || 0) * 100).toFixed(2)}%)`)
            .join("<br/>");
          strategyEl.innerHTML = `${data.strategy.recommendation}<br/><br/><span class="muted">Stable collateral APR ranking</span><br/>${rows || "none"}`;
        } else {
          strategyEl.innerHTML = `<span class="warn">No strategy data</span>`;
        }

        tokensEl.innerHTML = "";
        for (const row of data.tokens) {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${row.symbol}</td><td>${row.amount}</td><td>$${(row.usd || 0).toFixed(2)}</td><td>${row.error ? `<span class="warn">${row.error}</span>` : "ok"}</td>`;
          tokensEl.appendChild(tr);
        }

        txsEl.innerHTML = "";
        for (const tx of data.recentTxs || []) {
          const tr = document.createElement("tr");
          const hash = tx.explorerUrl ? `<a href="${tx.explorerUrl}" target="_blank" rel="noreferrer">${tx.txHash}</a>` : tx.txHash;
          tr.innerHTML = `<td>${new Date(tx.timestamp).toLocaleString()}</td><td>${tx.tool}</td><td>${hash}</td>`;
          txsEl.appendChild(tr);
        }

        actionsEl.innerHTML = "";
        for (const row of data.actionHistory || []) {
          const tr = document.createElement("tr");
          const status = row.status === "success" ? `<span class="ok">success</span>` : `<span class="warn">error</span>`;
          const tx = row.txHash
            ? (row.explorerUrl
                ? `<a href="${row.explorerUrl}" target="_blank" rel="noreferrer">${row.txHash}</a>`
                : row.txHash)
            : "-";
          tr.innerHTML = `<td>${new Date(row.timestamp).toLocaleString()}</td><td>${row.action}</td><td>${row.step || "-"}</td><td>${status}</td><td>${tx}</td><td>${row.summary || ""}</td>`;
          actionsEl.appendChild(tr);
        }
      }

      function setCommand(text) {
        cmdOutEl.value = text;
        cmdMetaEl.textContent = "Command generated";
      }

      function currentAccount() {
        return (accountInput.value || "davirain8.near").trim();
      }

      buildWrapBtn.addEventListener("click", () => {
        const amount = (wrapAmountEl.value || "1").trim();
        setCommand(`near contract call-function as-transaction wrap.near near_deposit json-args '{}' prepaid-gas '100 Tgas' attached-deposit '${amount} NEAR' sign-as ${currentAccount()} network-config mainnet sign-with-keychain send`);
      });

      buildSupplyBtn.addEventListener("click", () => {
        const raw = (supplyRawEl.value || "1000000").trim();
        setCommand(`near_supplyBurrow network=mainnet rpcUrl=https://1rpc.io/near tokenId=usdt.tether-token.near amountRaw=${raw} asCollateral=true confirmMainnet=true`);
      });

      buildWorkerDryBtn.addEventListener("click", () => {
        setCommand(`near_yieldWorkerStart network=mainnet accountId=${currentAccount()} dryRun=true intervalSeconds=300 minAprDelta=0.5 topN=5`);
      });

      buildWorkerStopBtn.addEventListener("click", () => {
        setCommand(`near_yieldWorkerStop network=mainnet accountId=${currentAccount()}`);
      });

      copyCmdBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(cmdOutEl.value || "");
          cmdMetaEl.textContent = "Copied";
        } catch {
          cmdMetaEl.textContent = "Copy failed";
        }
      });

      testAlertsBtn.addEventListener("click", async () => {
        const ok = window.confirm("Send a test alert to configured channels?");
        if (!ok) return;
        cmdMetaEl.textContent = "Sending alert test...";
        try {
          const res = await fetch("/api/alerts/test", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              confirm: true,
              accountId: currentAccount(),
              level: "info",
              title: "Dashboard alert test",
              message: `manual test from dashboard at ${new Date().toLocaleString()}`,
            }),
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Alert test failed");
          const tg = data?.channel?.telegram ? "telegram:on" : "telegram:off";
          const wh = data?.channel?.webhook ? "webhook:on" : "webhook:off";
          cmdMetaEl.textContent = `Alert test sent (${tg}, ${wh})`;
        } catch (e) {
          cmdMetaEl.textContent = `Alert test failed: ${e.message || e}`;
        }
      });

      async function executeAction(payload) {
        const ok = window.confirm("This will execute an on-chain transaction. Continue?");
        if (!ok) return;
        cmdMetaEl.textContent = "Executing...";
        try {
          const res = await fetch("/api/action", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...payload, confirm: true, accountId: currentAccount() }),
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Action failed");
          cmdOutEl.value = data.output || "Done";
          cmdMetaEl.textContent = "Executed";
          await load();
        } catch (e) {
          cmdMetaEl.textContent = `Execution failed: ${e.message || e}`;
        }
      }

      execWrapBtn.addEventListener("click", () => {
        executeAction({
          action: "wrap_near",
          amountNear: (wrapAmountEl.value || "1").trim(),
          step: (execStepTagEl.value || "").trim() || null,
        });
      });

      execSupplyBtn.addEventListener("click", () => {
        executeAction({
          action: "supply_usdt_collateral",
          amountRaw: (supplyRawEl.value || "1000000").trim(),
          step: (execStepTagEl.value || "").trim() || null,
        });
      });

      exportCsvBtn.addEventListener("click", () => {
        if (!lastSnapshot) {
          exportMetaEl.textContent = "No snapshot to export";
          return;
        }
        const csv = toCsv(lastSnapshot);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `near-dashboard-${lastSnapshot.accountId}-${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        exportMetaEl.textContent = "Exported";
      });

      saveTargetsBtn.addEventListener("click", () => {
        targetConfig = {
          usdt: parseNum(targetUsdtEl.value),
          usdce: parseNum(targetUsdceEl.value),
          threshold: parseNum(targetThresholdEl.value),
        };
        const totalTarget = targetConfig.usdt + targetConfig.usdce;
        if (Math.abs(totalTarget - 100) > 0.01) {
          targetAlertEl.innerHTML = `<span class="warn">Target total should be 100% (current ${totalTarget.toFixed(1)}%)</span>`;
          return;
        }
        saveTargets(targetConfig);
        if (lastSnapshot) {
          targetAlertEl.innerHTML = computeTargetAlert(lastSnapshot, targetConfig);
          const plan = computeRebalancePlan(lastSnapshot, targetConfig);
          lastRebalancePlan = plan;
          targetPlanEl.textContent = plan.text;
        }
      });

      function toRaw6(uiAmount) {
        return String(Math.max(0, Math.round(parseNum(uiAmount) * 1_000_000)));
      }

      function tokenIdFromSymbol(symbol) {
        return symbol === "USDt"
          ? "usdt.tether-token.near"
          : "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near";
      }

      function buildRebalanceDraft(snapshot, targets, chain = "near") {
        const plan = computeRebalancePlan(snapshot, targets);
        if (!plan.from || !plan.to || plan.amount <= 0) {
          return { plan, text: "# No executable rebalance draft\n# Reason: " + plan.text };
        }

        const fromToken = tokenIdFromSymbol(plan.from);
        const toToken = tokenIdFromSymbol(plan.to);
        const raw = toRaw6(plan.amount);

        if (chain === "bsc") {
          return {
            plan,
            text: [
              `# Rebalance draft (${plan.from} -> ${plan.to}) [BSC skeleton]`,
              `# Estimated move amount: ${plan.amount.toFixed(6)} (${raw} raw-equivalent)`,
              `1) Withdraw source asset from lending protocol (BSC adapter)`,
              `2) Swap on Pancake/aggregator (BSC adapter) with slippage guard`,
              `3) Re-supply target asset to lending protocol (BSC adapter)`,
              `# Note: one-click transaction orchestration for BSC is not enabled yet in this dashboard backend.`,
            ].join("\n"),
          };
        }

        return {
          plan,
          text: [
            `# Rebalance draft (${plan.from} -> ${plan.to})`,
            `# Estimated move amount: ${plan.amount.toFixed(6)} (${raw} raw)`,
            `1) Withdraw from Burrow: near_withdrawBurrow network=mainnet tokenId=${fromToken} amountRaw=${raw} confirmMainnet=true`,
            `2) Swap on Ref: near_swapRef network=mainnet tokenInId=${fromToken} tokenOutId=${toToken} amountInRaw=${raw} slippageBps=50 confirmMainnet=true`,
            `3) Supply to Burrow: near_supplyBurrow network=mainnet tokenId=${toToken} amountRaw=<use swap output raw> asCollateral=true confirmMainnet=true`,
          ].join("\n"),
        };
      }

      function buildActionConsoleFromPlan(plan, chain = "near") {
        if (!plan || !plan.from || !plan.to || plan.amount <= 0) {
          return "# No executable plan to fill\n# Refresh snapshot and confirm target settings.";
        }
        const fromToken = tokenIdFromSymbol(plan.from);
        const toToken = tokenIdFromSymbol(plan.to);
        const raw = toRaw6(plan.amount);
        if (chain === "bsc") {
          return [
            `# Checklist [BSC skeleton]`,
            `# 1) chain: bsc`,
            `# 2) amount: ${plan.amount.toFixed(6)} (${raw} raw-equivalent)`,
            `# 3) route through BSC adapter`,
            ``,
            `# TODO: bsc_withdraw`,
            `# TODO: bsc_swap`,
            `# TODO: bsc_supply`,
          ].join("\n");
        }
        return [
          `# Checklist`,
          `# 1) account: ${currentAccount()}`,
          `# 2) network: mainnet`,
          `# 3) amount: ${plan.amount.toFixed(6)} (${raw} raw)`,
          `# 4) confirm before each execute`,
          ``,
          `near_withdrawBurrow network=mainnet tokenId=${fromToken} amountRaw=${raw} confirmMainnet=true`,
          `near_swapRef network=mainnet tokenInId=${fromToken} tokenOutId=${toToken} amountInRaw=${raw} slippageBps=50 confirmMainnet=true`,
          `near_supplyBurrow network=mainnet tokenId=${toToken} amountRaw=<use swap output raw> asCollateral=true confirmMainnet=true`,
        ].join("\n");
      }

      buildRebalanceDraftBtn.addEventListener("click", () => {
        if (!lastSnapshot) {
          rebalanceMetaEl.textContent = "No snapshot loaded";
          return;
        }
        const chain = (rebalanceChainEl.value || "near").trim();
        const draft = buildRebalanceDraft(lastSnapshot, targetConfig, chain);
        lastRebalancePlan = draft.plan;
        rebalanceDraftEl.value = draft.text;
        rebalanceMetaEl.textContent = `Draft built (${chain})`;
      });

      copyRebalanceDraftBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(rebalanceDraftEl.value || "");
          rebalanceMetaEl.textContent = "Draft copied";
        } catch {
          rebalanceMetaEl.textContent = "Copy failed";
        }
      });

      fillActionConsoleBtn.addEventListener("click", () => {
        const chain = (rebalanceChainEl.value || "near").trim();
        cmdOutEl.value = buildActionConsoleFromPlan(lastRebalancePlan, chain);
        cmdMetaEl.textContent = `Filled from rebalance plan (${chain})`;
      });

      execRebalanceTxnBtn.addEventListener("click", () => {
        const chain = (rebalanceChainEl.value || "near").trim();
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          rebalanceMetaEl.textContent = "No executable rebalance plan";
          return;
        }
        if (chain === "bsc") {
          executeAction({
            action: "rebalance_usdt_to_usdce_txn",
            chain,
            amountRaw: p.raw,
            slippageBps: 50,
            step: (execStepTagEl.value || "rebalance-bsc-plan").trim() || "rebalance-bsc-plan",
          });
          rebalanceMetaEl.textContent = "Submitted BSC plan-only action";
          return;
        }
        if (p.fromToken !== "usdt.tether-token.near" || p.toToken !== "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near") {
          rebalanceMetaEl.textContent = "One-click tx currently supports USDt -> USDC.e only";
          return;
        }
        executeAction({
          action: "rebalance_usdt_to_usdce_txn",
          chain,
          amountRaw: p.raw,
          slippageBps: 50,
          poolId: 3725,
          step: (execStepTagEl.value || "rebalance").trim() || "rebalance",
        });
      });

      function getPlanTokensAndRaw(plan) {
        if (!plan || !plan.from || !plan.to || plan.amount <= 0) {
          return null;
        }
        return {
          fromToken: tokenIdFromSymbol(plan.from),
          toToken: tokenIdFromSymbol(plan.to),
          raw: toRaw6(plan.amount),
        };
      }

      buildStep1Btn.addEventListener("click", () => {
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          cmdMetaEl.textContent = "No executable plan";
          return;
        }
        cmdOutEl.value = `near_withdrawBurrow network=mainnet tokenId=${p.fromToken} amountRaw=${p.raw} confirmMainnet=true`;
        cmdMetaEl.textContent = "Step1 prepared";
      });

      buildStep2Btn.addEventListener("click", () => {
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          cmdMetaEl.textContent = "No executable plan";
          return;
        }
        cmdOutEl.value = `near_swapRef network=mainnet tokenInId=${p.fromToken} tokenOutId=${p.toToken} amountInRaw=${p.raw} slippageBps=50 confirmMainnet=true`;
        cmdMetaEl.textContent = "Step2 prepared";
      });

      buildStep3Btn.addEventListener("click", () => {
        const p = getPlanTokensAndRaw(lastRebalancePlan);
        if (!p) {
          cmdMetaEl.textContent = "No executable plan";
          return;
        }
        const outRaw = (step2OutRawEl.value || "").trim();
        if (!outRaw) {
          cmdMetaEl.textContent = "Paste Step2 output raw first";
          return;
        }
        cmdOutEl.value = `near_supplyBurrow network=mainnet tokenId=${p.toToken} amountRaw=${outRaw} asCollateral=true confirmMainnet=true`;
        cmdMetaEl.textContent = "Step3 prepared from Step2 output";
      });

      parseStep2RawBtn.addEventListener("click", () => {
        const text = (step2ResultTextEl.value || "").trim();
        if (!text) {
          cmdMetaEl.textContent = "Paste Step2 result text first";
          return;
        }
        const m = text.match(/raw\s+(\d{2,})/) || text.match(/->\s*(\d{2,})\s*raw/i) || text.match(/\b(\d{2,})\b/);
        if (!m) {
          cmdMetaEl.textContent = "Could not parse raw output";
          return;
        }
        step2OutRawEl.value = m[1];
        cmdMetaEl.textContent = `Parsed raw output: ${m[1]}`;
      });

      function renderStrategyDslHints(result) {
        const errs = Array.isArray(result?.errors) ? result.errors : [];
        const warns = Array.isArray(result?.warnings) ? result.warnings : [];
        const fieldMap = {};
        const pickKey = (line) => {
          const m = String(line || "").match(/^([a-zA-Z0-9_.-]+):/);
          return m ? m[1] : null;
        };
        for (const item of errs) {
          const k = pickKey(item);
          if (!k) continue;
          fieldMap[k] = fieldMap[k] || { errors: [], warnings: [] };
          fieldMap[k].errors.push(item);
        }
        for (const item of warns) {
          const k = pickKey(item);
          if (!k) continue;
          fieldMap[k] = fieldMap[k] || { errors: [], warnings: [] };
          fieldMap[k].warnings.push(item);
        }
        const lines = [];
        if (Object.keys(fieldMap).length > 0) {
          lines.push("Field hints:");
          for (const [k, v] of Object.entries(fieldMap)) {
            const e = v.errors.length ? `errors=${v.errors.length}` : "";
            const w = v.warnings.length ? `warnings=${v.warnings.length}` : "";
            lines.push(`- ${k} ${[e, w].filter(Boolean).join(" ")}`);
          }
        }
        return lines.join("\n");
      }

      async function runStrategyDslValidate() {
        let payload;
        try {
          payload = JSON.parse(strategyDslInputEl.value || "{}");
        } catch (e) {
          strategyDslMetaEl.textContent = `Invalid JSON: ${e.message || e}`;
          return { ok: false, localError: true };
        }
        const res = await fetch("/api/strategies/validate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await res.json().catch(() => ({}));
        const hints = renderStrategyDslHints(data);
        strategyDslResultEl.textContent = `${JSON.stringify(data, null, 2)}${hints ? `\n\n${hints}` : ""}`;
        strategyDslMetaEl.textContent = data?.ok
          ? `Ready (${data.phase || "ready"})`
          : `Validation failed (${data.phase || "unknown"})`;
        return { ok: !!data?.ok, payload, validation: data };
      }

      async function pollAcpAsyncJob(jobId) {
        if (!jobId) return;
        try {
          const res = await fetch(`/api/acp/jobs/${encodeURIComponent(jobId)}`);
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            acpAsyncStatusEl.textContent = `job=${jobId} query failed`;
            return;
          }
          const row = data.job || {};
          acpAsyncStatusEl.textContent = `job=${row.jobId} status=${row.status} updated=${row.updatedAt || "-"}${row.error ? ` error=${row.error}` : ""}`;
          if (row.status === "queued" || row.status === "running") {
            setTimeout(() => pollAcpAsyncJob(jobId), 1500);
          } else {
            load().catch(() => {});
          }
        } catch (e) {
          acpAsyncStatusEl.textContent = `job=${jobId} polling error: ${e.message || e}`;
        }
      }

      fillStrategyDslSampleBtn?.addEventListener("click", () => {
        strategyDslInputEl.value = JSON.stringify(buildStrategyDslSample(), null, 2);
        strategyDslMetaEl.textContent = "Sample filled";
      });

      validateStrategyDslBtn?.addEventListener("click", async () => {
        strategyDslMetaEl.textContent = "Validating...";
        strategyDslResultEl.textContent = "-";
        try {
          await runStrategyDslValidate();
        } catch (e) {
          strategyDslMetaEl.textContent = `Validate request failed: ${e.message || e}`;
        }
      });

      publishStrategyDslBtn?.addEventListener("click", async () => {
        strategyDslMetaEl.textContent = "Preflight + publishing...";
        strategyDslResultEl.textContent = "-";
        try {
          const first = await runStrategyDslValidate();
          if (!first.ok || !first.payload) {
            return;
          }
          const yes = window.confirm("Validation passed. Publish this strategy now?");
          if (!yes) {
            strategyDslMetaEl.textContent = "Publish canceled";
            return;
          }
          const publishPayload = {
            ...first.payload,
            confirm: true,
          };
          const pubRes = await fetch("/api/strategies", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(publishPayload),
          });
          const pubData = await pubRes.json().catch(() => ({}));
          strategyDslResultEl.textContent = JSON.stringify(pubData, null, 2);
          if (!pubRes.ok || !pubData?.ok) {
            strategyDslMetaEl.textContent = `Publish failed: ${pubData?.error || pubRes.status}`;
            return;
          }
          strategyDslMetaEl.textContent = `Published: ${pubData?.strategy?.id || "ok"}`;
        } catch (e) {
          strategyDslMetaEl.textContent = `Publish request failed: ${e.message || e}`;
        }
      });

      submitAcpAsyncJobBtn?.addEventListener("click", async () => {
        acpAsyncMetaEl.textContent = "Submitting...";
        const payload = {
          confirm: true,
          dryRun: false,
          intentType: "rebalance",
          amountRaw: String((acpAsyncAmountRawEl?.value || "1000000").trim() || "1000000"),
        };
        const strategyId = String((acpAsyncStrategyIdEl?.value || "").trim());
        const buyer = String((acpAsyncBuyerEl?.value || "").trim());
        if (strategyId) payload.strategyId = strategyId;
        if (buyer) payload.buyer = buyer;
        try {
          const res = await fetch("/api/acp/job/submit", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data?.ok) {
            acpAsyncMetaEl.textContent = `Submit failed: ${data?.error || res.status}`;
            return;
          }
          lastAcpAsyncJobId = data.jobId;
          acpAsyncMetaEl.textContent = `Submitted: ${data.jobId}`;
          acpAsyncStatusEl.textContent = `job=${data.jobId} status=${data.status}`;
          pollAcpAsyncJob(data.jobId);
          load().catch(() => {});
        } catch (e) {
          acpAsyncMetaEl.textContent = `Submit error: ${e.message || e}`;
        }
      });

      refreshBtn.addEventListener("click", () => load().catch((e) => (metaEl.textContent = e.message)));
      acpStatusFilterEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpBuyerFilterEl?.addEventListener("input", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpStrategyFilterEl?.addEventListener("input", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpOnlyFailedEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      acpExpandErrorsEl?.addEventListener("change", () => {
        syncAcpFiltersToUrl();
        load().catch(() => {});
      });
      copyAcpFilterLinkBtn?.addEventListener("click", async () => {
        syncAcpFiltersToUrl();
        const full = window.location.href;
        try {
          await navigator.clipboard.writeText(full);
          acpAsyncMetaEl.textContent = "Filter link copied";
        } catch {
          acpAsyncMetaEl.textContent = "Copy filter link failed";
        }
      });
      resetAcpFiltersBtn?.addEventListener("click", () => {
        resetAcpFilters();
        acpAsyncMetaEl.textContent = "ACP filters reset";
        load().catch(() => {});
      });
      applyAcpFiltersFromStorage();
      applyAcpFiltersFromUrl();
      syncAcpFiltersToUrl();
      load().catch((e) => (metaEl.textContent = e.message));
      setInterval(() => load().catch(() => {}), 30000);
    </script>
  </body>
</html>
